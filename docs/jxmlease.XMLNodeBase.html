<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>jxmlease.XMLNodeBase : API documentation</title>

    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link href="bootstrap.min.css" type="text/css" rel="stylesheet" />
    <link href="apidocs.css" type="text/css" rel="stylesheet" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a href="index.html" class="navbar-brand">
            jxmlease API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code>jxmlease.XMLNodeBase(<span title="XMLNodeMetaClass">XMLNodeMetaClass</span>)</code> <small>class documentation</small></h1>

        <span id="partOf">
          Part of <code><a href="jxmlease.html" class="code">jxmlease</a></code>
          
          <a href="classIndex.html#jxmlease.XMLNodeBase">(View In Hierarchy)</a>
        </span>
      </div>

      <div class="extrasDocstring">
        <p>Known subclasses: <a href="jxmlease.XMLCDATANode.html" class="code">jxmlease.XMLCDATANode</a>, <a href="jxmlease.XMLDictNode.html" class="code">jxmlease.XMLDictNode</a>, <a href="jxmlease.XMLListNode.html" class="code">jxmlease.XMLListNode</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p>This module provides methods common to the XML node classes.</p>
<p>This modules is not intended for standalone use. However, this documents
the general usage of the classes that inherit from it.</p>
<p>This class initializes an instance of an <a href="jxmlease.XMLNodeBase.html"><code>XMLNodeBase</code></a> 
sub-class.</p>
<p>The optional first parameter can be the value to which the object should
be initialized. All other parameters must be given as keywords.</p>
<p>Normally, the user can simply run this as:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>node = %s(initializer)</pre>
<p>In fact, the best way to use this is:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>root = XMLDictNode({<span class="py-string">'root'</span>: {<span class="py-string">'branch'</span>: { <span class="py-string">'leaf'</span>: <span class="py-string">'a'</span>}}})</pre>
<p>That will set all the tags, keys, etc. correctly. However, if you really
want to customize a node, there are other parameters available. Note that 
these parameters only impact <i>this</i> node and descendants. They don't 
actually add the node to a tree. Therefore, their use is discouraged. 
Instead, you can probably use the <a href="jxmlease.XMLNodeBase.html#add_node"><code>add_node</code></a> method 
to build your tree correctly.</p>
<p>The one exception to this general rule is when adding a hunk of a tree. 
For example, assume you currently have this XML structure: :</p>
<pre class="literalblock">
 &lt;a&gt;
   &lt;b&gt;
     &lt;node1&gt;a&lt;/node1&gt;
   &lt;/b&gt;
 &lt;/a&gt;
</pre>
<p>And, assume you want to add another node "b" to create this 
XML structure: :</p>
<pre class="literalblock">
 &lt;a&gt;
   &lt;b&gt;
     &lt;node1&gt;a&lt;/node1&gt;
   &lt;/b&gt;
   &lt;b&gt;
     &lt;node2&gt;b&lt;/node1&gt;
   &lt;/b&gt;
 &lt;/a&gt;
</pre>
<p>In that case, you might do something like this:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>root.prettyprint()
<span class="py-output">{u'a': {u'b': {u'node1': u'a'}}}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>new_b = {<span class="py-string">'node2'</span>: <span class="py-string">'b'</span>}
<span class="py-prompt">&gt;&gt;&gt; </span>new_b = XMLDictNode(new_b, tag=<span class="py-string">"b"</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>_ = root[<span class="py-string">'a'</span>].add_node(tag=<span class="py-string">"b"</span>, new_node=new_b)
<span class="py-prompt">&gt;&gt;&gt; </span>root.prettyprint()
<span class="py-output">{u'a': {u'b': [{u'node1': u'a'}, {'node2': u'b'}]}}</span></pre>
<p>And, you can print the XML to prove it is formatted correctly:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> root.emit_xml()
<span class="py-output">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="py-output">&lt;a&gt;</span>
<span class="py-output">    &lt;b&gt;</span>
<span class="py-output">        &lt;node1&gt;a&lt;/node1&gt;</span>
<span class="py-output">    &lt;/b&gt;</span>
<span class="py-output">    &lt;b&gt;</span>
<span class="py-output">        &lt;node2&gt;b&lt;/node2&gt;</span>
<span class="py-output">    &lt;/b&gt;</span>
<span class="py-output">&lt;/a&gt;</span></pre>
<p>User-supplied parameters:</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">initializer</td><td>The initial value for the node. (type: (as appropriate for node))</td></tr><tr><td></td><td class="fieldArg">tag</td><td>The XML tag for this node. (type: text)</td></tr><tr><td></td><td class="fieldArg">key</td><td>The dictionary key used for this node. (type: text)</td></tr><tr><td></td><td class="fieldArg">xml_attrs</td><td>The XML attributes for the node. (type: dict)</td></tr><tr><td></td><td class="fieldArg">text</td><td>The node's initial CDATA value. (Note that this is ignored for XMLCDATANode
objects.) (type: text)</td></tr><tr><td></td><td class="fieldArg">parent</td><td>A reference to the object's parent node in the data structure. (type: An instance of a sub-class of <a href="jxmlease.XMLNodeBase.html"><code>XMLNodeBase</code></a>)</td></tr><tr><td></td><td class="fieldArg">convert</td><td>If True, the <code>convert</code> method is run on the object's children 
during object initialization. (type: bool)</td></tr><tr><td></td><td class="fieldArg">deep</td><td>If True (and the convert parameter is True), the <code>convert</code> 
method is run recursively on the object's children during object 
initialization. (type: bool)</td></tr></table></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id6">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#has_xml_attrs" class="code">has_xml_attrs</a></td>
    <td><span>Determine if the node has XML attributes.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#set_xml_attr" class="code">set_xml_attr</a></td>
    <td><span>Set an XML attribute.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#get_xml_attr" class="code">get_xml_attr</a></td>
    <td><span>Get an XML attribute.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#get_xml_attrs" class="code">get_xml_attrs</a></td>
    <td><span>Return the XML attribute dictionary.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#delete_xml_attr" class="code">delete_xml_attr</a></td>
    <td><span>Delete an XML attribute.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#set_cdata" class="code">set_cdata</a></td>
    <td><span>Set a node's CDATA.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#append_cdata" class="code">append_cdata</a></td>
    <td><span>Append text to a node's CDATA.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#get_cdata" class="code">get_cdata</a></td>
    <td><span>Get a node's CDATA.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#strip_cdata" class="code">strip_cdata</a></td>
    <td><span>Strip leading/trailing characters from a node's CDATA.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#add_node" class="code">add_node</a></td>
    <td><span>Add an XML node to an XML tree.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#list" class="code">list</a></td>
    <td><span>Return a node as a list.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#get_current_node" class="code">get_current_node</a></td>
    <td><span>Return the current node.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#dict" class="code">dict</a></td>
    <td><span>Return a dictionary keyed as indicated by the parameters.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#standardize" class="code">standardize</a></td>
    <td><span>Convert all child nodes to instances of an <a href="jxmlease.XMLNodeBase.html"><code>XMLNodeBase</code></a> 
sub-class.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#emit_handler" class="code">emit_handler</a></td>
    <td><span>Pass the contents of the XML tree to a ContentHandler object.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#emit_xml" class="code">emit_xml</a></td>
    <td><span>Return the contents of the XML tree as an XML document.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#prettyprint" class="code">prettyprint</a></td>
    <td><span>Print a "pretty" representation of the data structure.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#__repr__" class="code">__repr__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#_check_replacement" class="code">_check_replacement</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="jxmlease.XMLNodeBase.html#_replace_node" class="code">_replace_node</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="function">
  <a name="jxmlease.XMLNodeBase.has_xml_attrs">
    
  </a>
  <a name="has_xml_attrs">
    
  </a>
  <div class="functionHeader">
    
    def
    has_xml_attrs(self):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Determine if the node has XML attributes.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">True if the node has XML attributes; otherwise, False. (type: boolean)</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase._check_replacement">
    
  </a>
  <a name="_check_replacement">
    
  </a>
  <div class="functionHeader">
    
    def
    _check_replacement(self):
    
  </div>
  <div class="docstring functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.set_xml_attr">
    
  </a>
  <a name="set_xml_attr">
    
  </a>
  <div class="functionHeader">
    
    def
    set_xml_attr(self, attr, val):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Set an XML attribute.</p>
<p>This method sets the XML attribute to the given value.  If the XML 
attribute already existed, its value is overridden by the new value.  If 
the XML attribute did not already exist, it is created.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">attr</td><td>The name of the XML attribute. (type: text)</td></tr><tr><td></td><td class="fieldArg">val</td><td>The value of the XML attribute. (type: text)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">None (type: None)</td></tr><tr class="fieldStart"><td class="fieldName">Raises</td><td colspan="2">AttributeError, if the node is out of date. (See <a href="jxmlease.XMLNodeBase.html#get_current_node"><code>get_current_node</code></a>.)</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.get_xml_attr">
    
  </a>
  <a name="get_xml_attr">
    
  </a>
  <div class="functionHeader">
    
    def
    get_xml_attr(self, attr, defval=_NoArg()):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Get an XML attribute.</p>
<p>This method returns the value of an XML attribute.  If the XML attribute
does not exist, it will return a user-supplied default value.  If the user 
did not supply a default value, it raises a KeyError.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">attr</td><td>The name of the XML attribute. (type: text)</td></tr><tr><td></td><td class="fieldArg">defval</td><td>The default value. (Default: Raise a KeyError.) (type: text)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">The value of the XML attribute, or defval.</td></tr><tr class="fieldStart"><td class="fieldName">Raises</td><td colspan="2">KeyError, if the attr is not found and defval is not supplied.</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.get_xml_attrs">
    
  </a>
  <a name="get_xml_attrs">
    
  </a>
  <div class="functionHeader">
    
    def
    get_xml_attrs(self):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Return the XML attribute dictionary.</p>
<p>This method returns the value of the XML attribute dictonary.  Note that
it returns the actual XML attribute dictionary, rather than a copy.  Please
take caution in modifying it.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">The XML attribute dictionary. (type: <a href="jxmlease.OrderedDict.html"><code>OrderedDict</code></a>)</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.delete_xml_attr">
    
  </a>
  <a name="delete_xml_attr">
    
  </a>
  <div class="functionHeader">
    
    def
    delete_xml_attr(self, attr):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Delete an XML attribute.</p>
<p>This method deletes an XML attribute from the node.  If the attribute 
does not exist, it raises a KeyError.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">attr</td><td>The name of the XML attribute. (type: text)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">None</td></tr><tr class="fieldStart"><td class="fieldName">Raises</td><td colspan="2">KeyError, if the attr is not found.</td></tr><tr><td></td><td colspan="2">AttributeError, if the node is out of date. (See <a href="jxmlease.XMLNodeBase.html#get_current_node"><code>get_current_node</code></a>.)</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.set_cdata">
    
  </a>
  <a name="set_cdata">
    
  </a>
  <div class="functionHeader">
    
    def
    set_cdata(self, cdata, return_node=False):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="jxmlease.XMLCDATANode.html" class="code">jxmlease.XMLCDATANode</a></div>
    <div><p>Set a node's CDATA.</p>
<p>This method sets a node's CDATA.  Note that any node can contain CDATA 
in what is called "semi-structured" XML. However, nodes that only
contain CDATA are represented as <a href="jxmlease.XMLCDATANode.html"><code>XMLCDATANode</code></a> objects. 
Regardless of the node, you can use this same method to set the CDATA.</p>
<p><b>Note</b>: When running this on an XMLCDATANode, the actual node will 
be replaced with a new node in the tree. (This is a result of Python's 
string immutability.)  The function will update the XML tree, if necessary;
however, any local references you have saved for the node will become 
stale.  You can obtain the updated node by setting the return_node 
parameter to True or by running the <a href="jxmlease.XMLNodeBase.html#get_current_node"><code>get_current_node</code></a>
method on the old node. For this reason, if you plan to keep a local 
reference to XML node in question, it is a good idea to run the method like
this:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>node = root[<span class="py-string">'a'</span>][<span class="py-string">'b'</span>][0]
<span class="py-prompt">&gt;&gt;&gt; </span>node = node.set_cdata(<span class="py-string">"foo"</span>, True)</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">cdata</td><td>The text value that should be used for the node's CDATA. (type: text)</td></tr><tr><td></td><td class="fieldArg">return_node</td><td>Whether the method should return the updated node. (type: bool)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">If return_node is False, None; otherwise, the updated node object. (type: None or an appropriate node object.)</td></tr><tr class="fieldStart"><td class="fieldName">Raises</td><td colspan="2">AttributeError, if the node is out of date. (See <a href="jxmlease.XMLNodeBase.html#get_current_node"><code>get_current_node</code></a>.)</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.append_cdata">
    
  </a>
  <a name="append_cdata">
    
  </a>
  <div class="functionHeader">
    
    def
    append_cdata(self, cdata, return_node=False):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="jxmlease.XMLCDATANode.html" class="code">jxmlease.XMLCDATANode</a></div>
    <div><p>Append text to a node's CDATA.</p>
<p>This method appends text to a node's CDATA.  Note that any node can 
contain CDATA in what is called "semi-structured" XML. However, 
nodes that only contain CDATA are represented as <a href="jxmlease.XMLCDATANode.html"><code>XMLCDATANode</code></a> objects. 
Regardless of the node, you can use this same method to append CDATA.</p>
<p><b>Note</b>: When running this on an XMLCDATANode, the actual node will 
be replaced with a new node in the tree. (This is a result of Python's 
string immutability.)  The function will update the XML tree, if necessary;
however, any local references you have saved for the node will become 
stale.  You can obtain the updated node by setting the return_node 
parameter to True or by running the <a href="jxmlease.XMLNodeBase.html#get_current_node"><code>get_current_node</code></a>
method on the old node. For this reason, if you plan to keep a local 
reference to XML node in question, it is a good idea to run the method like
this:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>node = root[<span class="py-string">'a'</span>][<span class="py-string">'b'</span>][0]
<span class="py-prompt">&gt;&gt;&gt; </span>node = node.append_cdata(<span class="py-string">"foo"</span>, True)</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">cdata</td><td>The text value that should be used for the node's CDATA. (type: text)</td></tr><tr><td></td><td class="fieldArg">return_node</td><td>Whether the method should return the updated node. (type: bool)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">If return_node is False, None; otherwise, the updated node object. (type: None or an appropriate node object.)</td></tr><tr class="fieldStart"><td class="fieldName">Raises</td><td colspan="2">AttributeError, if the node is out of date. (See <a href="jxmlease.XMLNodeBase.html#get_current_node"><code>get_current_node</code></a>.)</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.get_cdata">
    
  </a>
  <a name="get_cdata">
    
  </a>
  <div class="functionHeader">
    
    def
    get_cdata(self):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="jxmlease.XMLCDATANode.html" class="code">jxmlease.XMLCDATANode</a></div>
    <div><p>Get a node's CDATA.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">The node's CDATA. (type: text)</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.strip_cdata">
    
  </a>
  <a name="strip_cdata">
    
  </a>
  <div class="functionHeader">
    
    def
    strip_cdata(self, chars=None, return_node=False):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Strip leading/trailing characters from a node's CDATA.</p>
<p>This method runs the string class' strip() method on a node's CDATA and 
updates the node's CDATA with the result. (This is the functional 
equivalent to node.set_cdata(node.get_cdata().strip()).)</p>
<p>Note that any node can contain CDATA in what is called 
"semi-structured" XML. However, nodes that only contain CDATA are
represented as <a href="jxmlease.XMLCDATANode.html"><code>XMLCDATANode</code></a> objects. 
Regardless of the node, you can use this same method to append CDATA.</p>
<p><b>Note</b>: When running this on an XMLCDATANode, the actual node will 
be replaced with a new node in the tree. (This is a result of Python's 
string immutability.)  The function will update the XML tree, if necessary;
however, any local references you have saved for the node will become 
stale.  You can obtain the updated node by setting the return_node 
parameter to True or by running the <a href="jxmlease.XMLNodeBase.html#get_current_node"><code>get_current_node</code></a>
method on the old node. For this reason, if you plan to keep a local 
reference to XML node in question, it is a good idea to run the method like
this:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>node = root[<span class="py-string">'a'</span>][<span class="py-string">'b'</span>][0]
<span class="py-prompt">&gt;&gt;&gt; </span>node = node.strip_cdata(return_node=True)</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">chars</td><td>A string containing the characters to strip. This is passed to the string 
class' strip() method. (type: text)</td></tr><tr><td></td><td class="fieldArg">return_node</td><td>Whether the method should return the updated node. (type: bool)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">If return_node is False, None; otherwise, the updated node object. (type: None or an appropriate node object.)</td></tr><tr class="fieldStart"><td class="fieldName">Raises</td><td colspan="2">AttributeError, if the node is out of date. (See <a href="jxmlease.XMLNodeBase.html#get_current_node"><code>get_current_node</code></a>.)</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.add_node">
    
  </a>
  <a name="add_node">
    
  </a>
  <div class="functionHeader">
    
    def
    add_node(self, tag, key=None, text=_unicode(), new_node=None, update=True, **kwargs):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="jxmlease.XMLCDATANode.html" class="code">jxmlease.XMLCDATANode</a>, <a href="jxmlease.XMLDictNode.html" class="code">jxmlease.XMLDictNode</a>, <a href="jxmlease.XMLListNode.html" class="code">jxmlease.XMLListNode</a></div>
    <div><p>Add an XML node to an XML tree.</p>
<p>This method adds a new XML node as a child of the current node. If the 
current node is an XMLCDATANode, it will be converted to an XMLDictNode so 
that it can hold children. If the current node is an XMLDictNode and you 
attempt to add a node with a duplicate key, the code will create a list to 
hold the existing node and add the new node to the list.</p>
<p>By default, all new nodes are created as <a href="jxmlease.XMLCDATANode.html"><code>XMLCDATANode</code></a> objects. 
You can include any keyword parameters that you could provide when creating
an <a href="jxmlease.XMLCDATANode.html"><code>XMLCDATANode</code></a> 
object. If supplied, these additional keyword parameters are passed to the 
<a href="jxmlease.XMLCDATANode.html#__init__"><code>XMLCDATANode.__init__</code></a>
function.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">tag</td><td>The XML tag of the node. (type: text)</td></tr><tr><td></td><td class="fieldArg">key</td><td>The dictionary key that the method should use for the node. If None (the 
default), the tag is used as the key. (type: text)</td></tr><tr><td></td><td class="fieldArg">text</td><td>The CDATA for the new node. (Default: an empty string) (type: text)</td></tr><tr><td></td><td class="fieldArg">new_node</td><td>If supplied, this will be used for the new node instead of a new instance 
of the XMLCDATANode. If supplied, the text parameter and additional keyword
arguments are ignored. (type: An instance of a subclass of <a href="jxmlease.XMLNodeBase.html"><code>XMLNodeBase</code></a>.)</td></tr><tr><td></td><td class="fieldArg">update</td><td>If True (the default), update the reverse linkages in the new node to point
to the parent. If False, only create the one-way linkages from the parent 
to the child. (<b>Note</b>: This should always be True unless you are 
creating a temporary tree for some reason. Setting this to False may create
inconsistent data that causes problems later.) (type: bool)</td></tr><tr class="fieldStart"><td class="fieldName">Raises</td><td colspan="2">AttributeError, if the node is out of date and in_place is True. (See <a href="jxmlease.XMLNodeBase.html#get_current_node"><code>get_current_node</code></a>.)</td></tr><tr><td></td><td colspan="2">AttributeError, if in_place is True and the method encounters irrecoverable
data inconsistency while making changes to the XML tree.</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.list">
    
  </a>
  <a name="list">
    
  </a>
  <div class="functionHeader">
    
    def
    list(self, in_place=False):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="jxmlease.XMLListNode.html" class="code">jxmlease.XMLListNode</a></div>
    <div><p>Return a node as a list.</p>
<p>This method returns a node as a list. This is useful when you are not 
sure whether a node will contain a single entry or a list. If the node 
contains a list, the node itself is returned. If the node does not already 
contain a list, the method creates a list, adds the node to it, and returns
the list.</p>
<p>If the in_place parameter is True, then the change is made in the XML 
tree. Otherwise, the XML tree is left unchanged and the method creates and 
returns a temporary list.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">in_place</td><td>Whether the change should be made in the XML tree. (type: bool)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">If the current node is a list, the current node; otherwise, a list 
containing the current node as its sole member. (type: list or <a href="jxmlease.XMLListNode.html"><code>XMLListNode</code></a>)</td></tr><tr class="fieldStart"><td class="fieldName">Raises</td><td colspan="2">AttributeError, if the node is out of date and in_place is True. (See <a href="jxmlease.XMLNodeBase.html#get_current_node"><code>get_current_node</code></a>.)</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.get_current_node">
    
  </a>
  <a name="get_current_node">
    
  </a>
  <div class="functionHeader">
    
    def
    get_current_node(self):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Return the current node.</p>
<p>There are times that the current node must be replaced in the XML tree 
for some reason. For example, due to the immutability of Python strings, a 
new XMLCDATANode (which masquerades as a string) is required anytime its 
CDATA value changes.</p>
<p>When this occurs, you can retrieve the latest node using the 
get_current_node() method. This will attempt to find the node that 
succeeded the node in question. If the node is still current, it simply 
returns itself.</p>
<p>Therefore, it should always be safe to run:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>node = node.get_current_node()</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">The current successor to the node (if any). If the node is still 
"current", the method returns the node itself. (type: A subclass of XMLNodeBase)</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase._replace_node">
    
  </a>
  <a name="_replace_node">
    
  </a>
  <div class="functionHeader">
    
    def
    _replace_node(self, newnode):
    
  </div>
  <div class="docstring functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.dict">
    
  </a>
  <a name="dict">
    
  </a>
  <div class="functionHeader">
    
    def
    dict(self, attrs=[], tags=[], func=None, in_place=False, promote=False):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="jxmlease.XMLListNode.html" class="code">jxmlease.XMLListNode</a></div>
    <div><p>Return a dictionary keyed as indicated by the parameters.</p>
<p>This method lets you re-key your data with some flexibility. It takes 
the current node (whether a single node or a list) and turns it into a 
dictionary. If the current node is a list, all the list members are added 
to the dictionary. If the current node is not a list, just the current node
is added to the dictonary.</p>
<p>The key for each node is determined by the attrs, tags, and func 
parameters, in that order of precedence. For <i>each node</i>, the method 
looks for child nodes that have an XML attribute that exactly matches one 
of the attributes in the attrs argument. If it finds a match, it uses the 
<i>node's</i> (not the attribute's) CDATA as the key.</p>
<p>If the method does not find a matching attribute, it looks for child 
nodes that have a tag that exactly matches one of the tags in the tags 
argument. If it finds a match, it uses the node's CDATA as the key.</p>
<p>If the method does not find a matching tag, it passes the node to the 
user-suppled function (supplied by the func parameter) and uses the return 
value as the key.</p>
<p>If the func is not provided or returns a value that evaluates to False 
(e.g. None or ""), the method uses the node's XML tag as the 
key.</p>
<p>If there are multiple matches, the order of precedence is like this 
(again, this is applied for <i>each node</i> independent of the other 
nodes):</p>
<ol start="1">
  <li>
    The attributes in the attrs parameter, in the order they appear in the 
    attrs parameter.
  </li>
  <li>
    The tags in the tags parameter, in the order they appear in the attrs 
    parameter.
  </li>
  <li>
    The return value of the user-supplied function.
  </li>
  <li>
    The node's XML tag.
  </li>
</ol>
<p>If the in_place parameter is True, then the method will replace the 
current node in the hierarchy with the dictionary. Otherwise, it will 
create a new dictionary and return it.</p>
<p>If both the in_place and promote parameters are True, then the method 
will make the changes as described above; however, it will add the nodes to
the first dictionary it finds enclosing the curent node.</p>
<p>Some examples should help with this. Here is an example of the simple 
functionality. Note how the original nodes are turned into a dictionary 
with the appropriate keys, but the original root is left untouched:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>root.prettyprint()
<span class="py-output">{'a': {'b': [{'name': u'foo', 'value': u'1'},</span>
<span class="py-output">             {'name': u'bar', 'value': u'2'}]}}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>root[<span class="py-string">'a'</span>][<span class="py-string">'b'</span>].dict(tags=[<span class="py-string">'name'</span>]).prettyprint()
<span class="py-output">{u'bar': {'name': u'bar', 'value': u'2'},</span>
<span class="py-output"> u'foo': {'name': u'foo', 'value': u'1'}}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>root.prettyprint()
<span class="py-output">{'a': {'b': [{'name': u'foo', 'value': u'1'},</span>
<span class="py-output">             {'name': u'bar', 'value': u'2'}]}}</span></pre>
<p>Here is an example of a dictionary changed in place. Note how the 
original nodes are turned into a dictionary with the appropriate keys and 
this dictionary replaces the current node in the hierarchy:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>root.prettyprint()
<span class="py-output">{'a': {'b': [{'name': u'foo', 'value': u'1'},</span>
<span class="py-output">             {'name': u'bar', 'value': u'2'}]}}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>root[<span class="py-string">'a'</span>][<span class="py-string">'b'</span>].dict(tags=[<span class="py-string">'name'</span>], in_place=True).prettyprint()
<span class="py-output">{u'bar': {'name': u'bar', 'value': u'2'},</span>
<span class="py-output"> u'foo': {'name': u'foo', 'value': u'1'}}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>root.prettyprint()
<span class="py-output">{'a': {'b': {u'bar': {'name': u'bar', 'value': u'2'},</span>
<span class="py-output">             u'foo': {'name': u'foo', 'value': u'1'}}}}</span></pre>
<p>Here is an example of the "promotion" functionality. Note how 
the original nodes are added directly to the root['a'] enclosing 
dictionary:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>root.prettyprint()
<span class="py-output">{'a': {'b': [{'name': u'foo', 'value': u'1'},</span>
<span class="py-output">             {'name': u'bar', 'value': u'2'}]}}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>root[<span class="py-string">'a'</span>][<span class="py-string">'b'</span>].dict(tags=[<span class="py-string">'name'</span>], in_place=True, promote=True).prettyprint()
<span class="py-output">{u'bar': {'name': u'bar', 'value': u'2'},</span>
<span class="py-output"> u'foo': {'name': u'foo', 'value': u'1'}}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>root.prettyprint()
<span class="py-output">{'a': {u'bar': {'name': u'bar', 'value': u'2'},</span>
<span class="py-output">       u'foo': {'name': u'foo', 'value': u'1'}}}</span></pre>
<p>Quirks:</p>
<ol start="1">
  <li>
    If the current node is the only member of a list in the XML tree, the 
    operation will occur on that single-node list instead of the node 
    itself.
  </li>
  <li>
    If the method encounters an exception while trying to modify the XML 
    tree (in_place == True), it will attempt to undo its changes; however, 
    this logic is not completely reliable.
  </li>
</ol><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">attrs</td><td>The list of XML attributes that signal a node should be used as a key. (type: list)</td></tr><tr><td></td><td class="fieldArg">attrs</td><td>The list of XML tags that signal a node should be used as a key. (type: list)</td></tr><tr><td></td><td class="fieldArg">func</td><td>A function that will accept a node as a parameter and return a key. (type: function)</td></tr><tr><td></td><td class="fieldArg">in_place</td><td>Whether the change should be made in the XML tree. (type: bool)</td></tr><tr><td></td><td class="fieldArg">promote</td><td>Whether the new nodes should be added to a dictonary placed at the current 
node, or they should be "promoted" to the first enclosing 
dictionary. (type: bool)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">If in_place is False, a dictionary formulated from the current node. If 
in_place is True, the dictionary to which the nodes were added. (Note: If 
promote is True, this dictionary may contain additional entries that 
already existed in the enclosing dictionary.) (type: <a href="jxmlease.XMLDictNode.html"><code>XMLDictNode</code></a>)</td></tr><tr class="fieldStart"><td class="fieldName">Raises</td><td colspan="2">AttributeError, if the node is out of date and in_place is True. (See <a href="jxmlease.XMLNodeBase.html#get_current_node"><code>get_current_node</code></a>.)</td></tr><tr><td></td><td colspan="2">AttributeError, if in_place is True and the method encounters irrecoverable
data inconsistency while making changes to the XML tree.</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.standardize">
    
  </a>
  <a name="standardize">
    
  </a>
  <div class="functionHeader">
    
    def
    standardize(self, deep=True):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="jxmlease.XMLCDATANode.html" class="code">jxmlease.XMLCDATANode</a>, <a href="jxmlease.XMLDictNode.html" class="code">jxmlease.XMLDictNode</a>, <a href="jxmlease.XMLListNode.html" class="code">jxmlease.XMLListNode</a></div>
    <div><p>Convert all child nodes to instances of an <a href="jxmlease.XMLNodeBase.html"><code>XMLNodeBase</code></a> 
sub-class.</p>
<p>This method is useful when you have added a child node directly to a 
dictionary or list and now want to convert it to the appropriate <a href="jxmlease.XMLNodeBase.html"><code>XMLNodeBase</code></a> 
sub-class.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">deep</td><td>If True (the default), recursively descend through all children, converting
all nodes, as needed. If False, only convert direct children of the node. (type: bool)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">None</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.emit_handler">
    
  </a>
  <a name="emit_handler">
    
  </a>
  <div class="functionHeader">
    
    def
    emit_handler(self, content_handler, pretty=True, newl='\n', indent='    ', full_document=_NoArg()):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Pass the contents of the XML tree to a ContentHandler object.</p>
<p>This method will pass the contents of the XML tree to a ContentHandler 
object.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">content_handler</td><td>The ContentHandler object to which the XML tree wll be passed. (type: A ContentHandler object)</td></tr><tr><td></td><td class="fieldArg">pretty</td><td>If True, this method will call the content_handler.ignorableWhitespace() 
method to add whitespace to the output document. (type: bool)</td></tr><tr><td></td><td class="fieldArg">newl</td><td>The string which the method should use for new lines when adding white 
space (see the pretty parameter). (type: text)</td></tr><tr><td></td><td class="fieldArg">indent</td><td>The string which the method should use for each level of indentation when 
adding white space (see the pretty parameter). (type: text)</td></tr><tr><td></td><td class="fieldArg">full_document</td><td>If True, the method will call the content_handler.startDocument() and 
content_handler.endDocument() methods at the start and end of the document,
respectively. If False, it will not call these methods. If the parameter is
not set, the method will attempt to determine whether the current node is 
the root of an XML tree with a single root tag. If so, it will set the 
full_document parameter to True; otherwise, it will set it to False. (type: bool)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">None</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.emit_xml">
    
  </a>
  <a name="emit_xml">
    
  </a>
  <div class="functionHeader">
    
    def
    emit_xml(self, output=None, encoding='utf-8', handler=XMLGenerator, **kwargs):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Return the contents of the XML tree as an XML document.</p>
<p>This method will create a ContentHandler by calling the method provided 
by the handler parameter.  It will call <a href="jxmlease.XMLNodeBase.html#emit_handler"><code>emit_handler</code></a>
with this ContentHandler object.  In addition, this method will accept any 
parameter that the <a href="jxmlease.XMLNodeBase.html#emit_handler"><code>emit_handler</code></a>
method accepts (except the content_handler parameter).  It will pass them 
to the <a href="jxmlease.XMLNodeBase.html#emit_handler"><code>emit_handler</code></a>
method when it calls it.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">output</td><td>The file-like IO object in which output should be placed. If None, the 
method will return the XML output as a string. (type: A file-like IO object, or None.)</td></tr><tr><td></td><td class="fieldArg">encoding</td><td>The encoding that should be used for the output. (type: text)</td></tr><tr><td></td><td class="fieldArg">handler</td><td>A method that will return a ContentHandler object. This method will be 
called with two positional parameters: the output parameter (or, if None, a
file-like IO object) and the encoding parameter. (type: function)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">If output was None, the method will return the XML output as a string. 
Otherwise, None.</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.prettyprint">
    
  </a>
  <a name="prettyprint">
    
  </a>
  <div class="functionHeader">
    
    def
    prettyprint(self, *args, **kwargs):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="jxmlease.XMLCDATANode.html" class="code">jxmlease.XMLCDATANode</a>, <a href="jxmlease.XMLDictNode.html" class="code">jxmlease.XMLDictNode</a>, <a href="jxmlease.XMLListNode.html" class="code">jxmlease.XMLListNode</a></div>
    <div><p>Print a "pretty" representation of the data structure.</p>
<p>This uses the Python pprint method to print a "pretty" 
representation of the data structure. The parameters are passed unchanged 
to the Python pprint method.</p>
<p>This shows only the main data and not the meta data (such as XML 
attributes).</p>
<p>When using pprint, it is necessary to use this method to get a 
reasonable representation of the data; otherwise, pprint will not know how 
to represent the object in a "pretty" way.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="jxmlease.XMLNodeBase.__repr__">
    
  </a>
  <a name="__repr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __repr__(self):
    
  </div>
  <div class="docstring functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for jxmlease, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> at 2015-10-28 17:03:03.
      </address>

    </div>
  </body>
</html>