<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Ojbects &mdash; jxmlease 0.0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="jxmlease 0.0.1 documentation" href="index.html" />
    <link rel="next" title="Iteration" href="iteration.html" />
    <link rel="prev" title="Parsing XML" href="parsing.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ojbects">
<h1>Ojbects<a class="headerlink" href="#ojbects" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="jxmlease.XMLDictNode">
<em class="property">class </em><code class="descclassname">jxmlease.</code><code class="descname">XMLDictNode</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/jxmlease.html#XMLDictNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#jxmlease.XMLDictNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an XMLDictNode object.</p>
<p>The optional first parameter can be the value to which the
object should be initialized. All other parameters must be
given as keywords.</p>
<p>Normally, the user can simply run this as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">node</span> <span class="o">=</span> <span class="n">XMLDictNode</span><span class="p">(</span><span class="n">initializer</span><span class="p">)</span>
</pre></div>
</div>
<p>In fact, the best way to use this is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">XMLDictNode</span><span class="p">({</span><span class="s1">&#39;root&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;branch&#39;</span><span class="p">:</span> <span class="p">{</span> <span class="s1">&#39;leaf&#39;</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">}}})</span>
</pre></div>
</div>
<p>That will set all the tags, keys, etc. correctly. However,
if you really want to customize a node, there are other
parameters available. Note that these parameters only
impact <em>this</em> node and descendants. They don&#8217;t actually
add the node to a tree. Therefore, their use is
discouraged. Instead, you can probably use the <a class="reference internal" href="#jxmlease.XMLDictNode.add_node" title="jxmlease.XMLDictNode.add_node"><code class="xref py py-meth docutils literal"><span class="pre">add_node()</span></code></a>
method to build your tree correctly.</p>
<p>The one exception to this general rule is when adding a
hunk of a tree. For example, assume you currently have this XML
structure:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">node1</span><span class="o">&gt;</span><span class="n">a</span><span class="o">&lt;/</span><span class="n">node1</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">b</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>And, assume you want to add another node <code class="docutils literal"><span class="pre">b</span></code> to create this
XML structure:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">node1</span><span class="o">&gt;</span><span class="n">a</span><span class="o">&lt;/</span><span class="n">node1</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">b</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">node2</span><span class="o">&gt;</span><span class="n">b</span><span class="o">&lt;/</span><span class="n">node1</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">b</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>In that case, you might do something like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">()</span>
<span class="go">{u&#39;a&#39;: {u&#39;b&#39;: {u&#39;node1&#39;: u&#39;a&#39;}}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_b</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;node2&#39;</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_b</span> <span class="o">=</span> <span class="n">XMLDictNode</span><span class="p">(</span><span class="n">new_b</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">new_node</span><span class="o">=</span><span class="n">new_b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">()</span>
<span class="go">{u&#39;a&#39;: {u&#39;b&#39;: [{u&#39;node1&#39;: u&#39;a&#39;}, {&#39;node2&#39;: u&#39;b&#39;}]}}</span>
</pre></div>
</div>
<p>And, you can print the XML to prove it is formatted correctly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">root</span><span class="o">.</span><span class="n">emit_xml</span><span class="p">()</span>
<span class="go">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="go">&lt;a&gt;</span>
<span class="go">    &lt;b&gt;</span>
<span class="go">        &lt;node1&gt;a&lt;/node1&gt;</span>
<span class="go">    &lt;/b&gt;</span>
<span class="go">    &lt;b&gt;</span>
<span class="go">        &lt;node2&gt;b&lt;/node2&gt;</span>
<span class="go">    &lt;/b&gt;</span>
<span class="go">&lt;/a&gt;</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>initializer</strong> (<em>as appropriate for node</em>) &#8211; The initial value for
the node.</li>
<li><strong>tag</strong> (<em>string</em>) &#8211; The XML tag for this node.</li>
<li><strong>key</strong> (<em>text or tuple</em>) &#8211; The dictionary key used for this node.</li>
<li><strong>xml_attrs</strong> &#8211; The XML attributes for the node.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="jxmlease.XMLDictNode.add_node">
<code class="descname">add_node</code><span class="sig-paren">(</span><em>tag</em>, <em>key=None</em>, <em>text=u''</em>, <em>new_node=None</em>, <em>update=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/jxmlease.html#XMLDictNode.add_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#jxmlease.XMLDictNode.add_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an XML node to an XML tree.</p>
<p>This method adds a new XML node as a child of the current
node. If the current node is an XMLCDATANode, it will be
converted to an XMLDictNode so that it can hold children. If
the current node is an XMLDictNode and you attempt to add a
node with a duplicate key, the code will create a list to hold
the existing node and add the new node to the list.</p>
<p>By default, all new nodes are created as L{XMLCDATANode}
objects. You can include any keyword parameters that you could
provide when creating an L{XMLCDATANode} object. If supplied,
these additional keyword parameters are passed to the
L{XMLCDATANode.__init__} function.</p>
<p>&#64;type tag: text
&#64;param tag: The XML tag of the node.
&#64;type key: text or tuple
&#64;param key: The dictionary key that the method should use for</p>
<blockquote>
<div>the node. If None (the default), the tag is used as the
key.</div></blockquote>
<p>&#64;type text: text
&#64;param text: The CDATA for the new node. (Default: an empty</p>
<blockquote>
<div>string)</div></blockquote>
<p>&#64;type new_node: An instance of a subclass of L{XMLNodeBase}.
&#64;param new_node: If supplied, this will be used for the new</p>
<blockquote>
<div>node instead of a new instance of the XMLCDATANode. If
supplied, the text parameter and additional keyword
arguments are ignored.</div></blockquote>
<p>&#64;type update: bool
&#64;param update: If True (the default), update the reverse</p>
<blockquote>
<div>linkages in the new node to point to the parent. If False,
only create the one-way linkages from the parent to the
child. (B{Note}: This should always be True unless you are
creating a temporary tree for some reason. Setting this to
False may create inconsistent data that causes problems later.)</div></blockquote>
<dl class="docutils">
<dt>&#64;raises: AttributeError, if the node is out of date and</dt>
<dd>in_place is True. (See L{get_current_node}.)</dd>
<dt>&#64;raises: AttributeError, if in_place is True and the method</dt>
<dd>encounters irrecoverable data inconsistency while making
changes to the XML tree.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.append_cdata">
<code class="descname">append_cdata</code><span class="sig-paren">(</span><em>cdata</em>, <em>return_node=False</em><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.append_cdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Append text to a node&#8217;s CDATA.</p>
<p>This method appends text to a node&#8217;s CDATA.  Note that any
node can contain CDATA in what is called &#8220;semi-structured&#8221;
XML. However, nodes that only contain CDATA are represented as
L{XMLCDATANode} objects. Regardless of the node, you can use
this same method to append CDATA.</p>
<p>B{Note}: When running this on an XMLCDATANode, the actual node
will be replaced with a new node in the tree. (This is a
result of Python&#8217;s string immutability.)  The function will
update the XML tree, if necessary; however, any local
references you have saved for the node will become stale.  You
can obtain the updated node by setting the return_node
parameter to True or by running the L{get_current_node} method
on the old node. For this reason, if you plan to keep a local
reference to XML node in question, it is a good idea to run
the method like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">append_cdata</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>&#64;type cdata: text
&#64;param cdata: The text value that should be used for the</p>
<blockquote>
<div>node&#8217;s CDATA.</div></blockquote>
<p>&#64;type return_node: bool
&#64;param return_node: Whether the method should return the</p>
<blockquote>
<div>updated node.</div></blockquote>
<p>&#64;rtype: None or an appropriate node object.
&#64;return: If return_node is False, None; otherwise, the updated</p>
<blockquote>
<div>node object.</div></blockquote>
<dl class="docutils">
<dt>&#64;raises: AttributeError, if the node is out of date. (See</dt>
<dd>L{get_current_node}.)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; None.  Remove all items from od.<a class="headerlink" href="#jxmlease.XMLDictNode.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; a shallow copy of od<a class="headerlink" href="#jxmlease.XMLDictNode.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.delete_xml_attr">
<code class="descname">delete_xml_attr</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.delete_xml_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete an XML attribute.</p>
<p>This method deletes an XML attribute from the node.  If the
attribute does not exist, it raises a KeyError.</p>
<p>&#64;type attr: text
&#64;param attr: The name of the XML attribute.
&#64;return: None
&#64;raises: KeyError, if the attr is not found.
&#64;raises: AttributeError, if the node is out of date. (See</p>
<blockquote>
<div>L{get_current_node}.)</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.dict">
<code class="descname">dict</code><span class="sig-paren">(</span><em>attrs=[]</em>, <em>tags=[]</em>, <em>func=None</em>, <em>in_place=False</em>, <em>promote=False</em><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary keyed as indicated by the parameters.</p>
<p>This method lets you re-key your data with some
flexibility. It takes the current node (whether a single node
or a list) and turns it into a dictionary. If the current node
is a list, all the list members are added to the
dictionary. If the current node is not a list, just the
current node is added to the dictonary.</p>
<p>The key for each node is determined by the attrs, tags, and
func parameters, in that order of precedence. For I{each
node}, the method looks for child nodes that have an
XML attribute that exactly matches one of the attributes in
the attrs argument. If it finds a match, it uses the I{node&#8217;s}
(not the attribute&#8217;s) CDATA as the key.</p>
<p>If the method does not find a matching attribute, it looks for
child nodes that have a tag that exactly matches one of the
tags in the tags argument. If it finds a match, it uses the
node&#8217;s CDATA as the key.</p>
<p>If the method does not find a matching tag, it passes the node
to the user-suppled function (supplied by the func parameter)
and uses the return value as the key.</p>
<p>If the func is not provided or returns a value that evaluates to
False (e.g. None or &#8220;&#8221;), the method uses the node&#8217;s XML tag as
the key.</p>
<p>If there are multiple matches, the order of precedence is like
this (again, this is applied for I{each node} independent of
the other nodes):</p>
<blockquote>
<div><ol class="arabic simple">
<li>The attributes in the attrs parameter, in the order they
appear in the attrs parameter.</li>
<li>The tags in the tags parameter, in the order they appear
in the attrs parameter.</li>
<li>The return value of the user-supplied function.</li>
<li>The node&#8217;s XML tag.</li>
</ol>
</div></blockquote>
<p>If the in_place parameter is True, then the method will
replace the current node in the hierarchy with the
dictionary. Otherwise, it will create a new dictionary and
return it.</p>
<p>If both the in_place and promote parameters are True, then the
method will make the changes as described above; however, it
will add the nodes to the first dictionary it finds enclosing
the curent node.</p>
<p>Some examples should help with this. Here is an example of the
simple functionality. Note how the original nodes are turned
into a dictionary with the appropriate keys, but the original
root is left untouched:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">()</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: [{&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;},</span>
<span class="go">             {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;}]}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">()</span>
<span class="go">{u&#39;bar&#39;: {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;},</span>
<span class="go"> u&#39;foo&#39;: {&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">()</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: [{&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;},</span>
<span class="go">             {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;}]}}</span>
</pre></div>
</div>
<p>Here is an example of a dictionary changed in place. Note how
the original nodes are turned into a dictionary with the
appropriate keys and this dictionary replaces the current node
in the hierarchy:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">()</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: [{&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;},</span>
<span class="go">             {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;}]}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">()</span>
<span class="go">{u&#39;bar&#39;: {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;},</span>
<span class="go"> u&#39;foo&#39;: {&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">()</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: {u&#39;bar&#39;: {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;},</span>
<span class="go">             u&#39;foo&#39;: {&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;}}}}</span>
</pre></div>
</div>
<p>Here is an example of the &#8220;promotion&#8221; functionality. Note how
the original nodes are added directly to the root[&#8216;a&#8217;]
enclosing dictionary:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">()</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: [{&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;},</span>
<span class="go">             {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;}]}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">promote</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">()</span>
<span class="go">{u&#39;bar&#39;: {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;},</span>
<span class="go"> u&#39;foo&#39;: {&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">()</span>
<span class="go">{&#39;a&#39;: {u&#39;bar&#39;: {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;},</span>
<span class="go">       u&#39;foo&#39;: {&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;}}}</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Quirks:</dt>
<dd><ol class="first last arabic simple">
<li>If the current node is the only member of a list in
the XML tree, the operation will occur on that single-node
list instead of the node itself.</li>
<li>If the method encounters an exception while trying to
modify the XML tree (in_place == True), it will attempt
to undo its changes; however, this logic is not
completely reliable.</li>
</ol>
</dd>
</dl>
<p>&#64;type attrs: list
&#64;param attrs: The list of XML attributes that signal a node</p>
<blockquote>
<div>should be used as a key.</div></blockquote>
<p>&#64;type tags: list
&#64;param attrs: The list of XML tags that signal a node</p>
<blockquote>
<div>should be used as a key.</div></blockquote>
<p>&#64;type func: function
&#64;param func: A function that will accept a node as a parameter</p>
<blockquote>
<div>and return a key.</div></blockquote>
<p>&#64;type in_place: bool
&#64;param in_place: Whether the change should be made in the XML</p>
<blockquote>
<div>tree.</div></blockquote>
<p>&#64;type promote: bool
&#64;param promote: Whether the new nodes should be added to a</p>
<blockquote>
<div>dictonary placed at the current node, or they should be
&#8220;promoted&#8221; to the first enclosing dictionary.</div></blockquote>
<p>&#64;rtype: L{XMLDictNode}
&#64;return: If in_place is False, a dictionary formulated from</p>
<blockquote>
<div>the current node. If in_place is True, the dictionary to which
the nodes were added. (Note: If promote is True, this
dictionary may contain additional entries that already
existed in the enclosing dictionary.)</div></blockquote>
<dl class="docutils">
<dt>&#64;raises: AttributeError, if the node is out of date and</dt>
<dd>in_place is True. (See L{get_current_node}.)</dd>
<dt>&#64;raises: AttributeError, if in_place is True and the method</dt>
<dd>encounters irrecoverable data inconsistency while making
changes to the XML tree.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.emit_handler">
<code class="descname">emit_handler</code><span class="sig-paren">(</span><em>content_handler</em>, <em>pretty=True</em>, <em>newl='\n'</em>, <em>indent='    '</em>, <em>full_document=&lt;jxmlease._NoArg instance&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.emit_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass the contents of the XML tree to a ContentHandler object.</p>
<p>This method will pass the contents of the XML tree to a
ContentHandler object.</p>
<p>&#64;type content_handler: A ContentHandler object
&#64;param content_handler: The ContentHandler object to which the</p>
<blockquote>
<div>XML tree wll be passed.</div></blockquote>
<p>&#64;type pretty: bool
&#64;param pretty: If True, this method will call the</p>
<blockquote>
<div>content_handler.ignorableWhitespace() method to add
whitespace to the output document.</div></blockquote>
<p>&#64;type newl: text
&#64;param newl: The string which the method should use for new</p>
<blockquote>
<div>lines when adding white space (see the pretty parameter).</div></blockquote>
<p>&#64;type indent: text
&#64;param indent: The string which the method should use for each</p>
<blockquote>
<div>level of indentation when adding white space (see the pretty
parameter).</div></blockquote>
<p>&#64;type full_document: bool
&#64;param full_document: If True, the method will call the</p>
<blockquote>
<div>content_handler.startDocument() and
content_handler.endDocument() methods at the start and end of
the document, respectively. If False, it will not call these
methods. If the parameter is not set, the method will
attempt to determine whether the current node is the root
of an XML tree with a single root tag. If so, it will set
the full_document parameter to True; otherwise, it will
set it to False.</div></blockquote>
<p>&#64;return: None</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.emit_xml">
<code class="descname">emit_xml</code><span class="sig-paren">(</span><em>output=None</em>, <em>encoding='utf-8'</em>, <em>handler=&lt;class xml.sax.saxutils.XMLGenerator&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.emit_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contents of the XML tree as an XML document.</p>
<p>This method will create a ContentHandler by calling the
method provided by the handler parameter.  It will call
L{emit_handler} with this ContentHandler object.  In addition,
this method will accept any parameter that the L{emit_handler}
method accepts (except the content_handler parameter).  It will pass
them to the L{emit_handler} method when it calls it.</p>
<p>&#64;type output: A file-like IO object, or None.
&#64;param output: The file-like IO object in which output should</p>
<blockquote>
<div>be placed. If None, the method will return the XML output
as a string.</div></blockquote>
<p>&#64;type encoding: text
&#64;param encoding: The encoding that should be used for the output.
&#64;type handler: function
&#64;param handler: A method that will return a ContentHandler</p>
<blockquote>
<div>object. This method will be called with two positional
parameters: the output parameter (or, if None, a file-like IO
object) and the encoding parameter.</div></blockquote>
<dl class="docutils">
<dt>&#64;return: If output was None, the method will return the XML</dt>
<dd>output as a string. Otherwise, None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.find_nodes_with_tag">
<code class="descname">find_nodes_with_tag</code><span class="sig-paren">(</span><em>tag</em>, <em>recursive=True</em><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.find_nodes_with_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over nodes that have a matching tag.</p>
<p>NOTE: This documentation needs to be updated to take into
account the changes to list handling and always checking the
current node&#8217;s tag.</p>
<p>This method searches for a node that is a descendant of the
current node and has a matching tag. Optionally (by providing
a False argument to the recursive parameter), you can limit
the search to direct children of the current node. In either
case, the tag of the current node is not checked.</p>
<p>For example, this will print all &#8220;name&#8221; nodes from the XML
snippet that is shown:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">jxmlease</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;          ... &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="gp">... </span><span class="s2">&lt;name&gt;</span>
<span class="gp">... </span><span class="s2">    &lt;a&gt;</span>
<span class="gp">... </span><span class="s2">        &lt;name&gt;name #1&lt;/name&gt;</span>
<span class="gp">... </span><span class="s2">        &lt;b&gt;</span>
<span class="gp">... </span><span class="s2">            &lt;name&gt;name #2&lt;/name&gt;</span>
<span class="gp">... </span><span class="s2">        &lt;/b&gt;</span>
<span class="gp">... </span><span class="s2">        &lt;b&gt;</span>
<span class="gp">... </span><span class="s2">            &lt;c&gt;</span>
<span class="gp">... </span><span class="s2">                &lt;name&gt;name #3&lt;/name&gt;</span>
<span class="gp">... </span><span class="s2">            &lt;/c&gt;</span>
<span class="gp">... </span><span class="s2">        &lt;/b&gt;</span>
<span class="gp">... </span><span class="s2">    &lt;/a&gt;</span>
<span class="gp">... </span><span class="s2">&lt;/name&gt;&quot;&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">root</span>
<span class="go">{u&#39;name&#39;: {u&#39;a&#39;: {u&#39;b&#39;: [{u&#39;name&#39;: u&#39;name #2&#39;},</span>
<span class="go">                         {u&#39;c&#39;: {u&#39;name&#39;: u&#39;name #3&#39;}}],</span>
<span class="go">                  u&#39;name&#39;: u&#39;name #1&#39;}}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">find_nodes_with_tag</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">):</span>
<span class="gp">... </span>  <span class="nb">print</span> <span class="n">node</span>
<span class="gp">...</span>
<span class="go">name #1</span>
<span class="go">name #2</span>
<span class="go">name #3</span>
</pre></div>
</div>
<p>However, if we turn off recursion, you will see that this
returns only the direct children (if any) of the node we
select:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">find_nodes_with_tag</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>  <span class="nb">print</span> <span class="n">node</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">][</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">find_nodes_with_tag</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>  <span class="nb">print</span> <span class="n">node</span>
<span class="gp">...</span>
<span class="go">name #1</span>
</pre></div>
</div>
<p>If you run this against an XMLDictNode without a tag (for
example, the tagless root node), then the command is run on
each member of the dictionary. The impact of this is that it
will search for tags in the grandchildren of the tagless
XMLDictNode, rather than searching the children of the tagless
XMLDictNode:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">jxmlease</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;&lt;name&gt;top-level tag&lt;/name&gt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">find_nodes_with_tag</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">):</span>
<span class="gp">... </span>  <span class="nb">print</span> <span class="n">i</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">jxmlease</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;          ... &lt;a&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;name&gt;second-level tag&lt;/name&gt;</span>
<span class="gp">... </span><span class="s2">&lt;/a&gt;&quot;&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">find_nodes_with_tag</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">):</span>
<span class="gp">... </span>  <span class="nb">print</span> <span class="n">i</span>
<span class="gp">...</span>
<span class="go">second-level tag</span>
</pre></div>
</div>
<p>If the current node is a list and it appears that the list was
created to hold multiple elements with the same tag, then the
command is run on each member of the list (rather than on the
list itself). The impact of this is that it will search for
tags in the grandchildren of the XMLListNode, rather
than searching the children of the XMLListNode.</p>
<p>As confusing as this may sound, the point is simple: we never
check the tag of the &#8220;current&#8221; element. Because lists can be
homogenous or heterogenous, that statement is ambiguous for
lists. We resolve the ambiguity by comparing the tag stored
with the list and the tag of the children. :</p>
<p>For example, here is a root node with two top-level &#8220;name&#8221;
elements. Searching for the &#8220;name&#8221; tag does not find these
top-level elements because both the top-level dictionary and
top-level list pass through the search:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">XMLDictNode</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;tag #1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;tag #2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">root</span>
<span class="go">{&#39;name&#39;: [u&#39;tag #1&#39;, u&#39;tag #2&#39;]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">find_nodes_with_tag</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">):</span>
<span class="gp">... </span>  <span class="nb">print</span> <span class="n">i</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>On the other hand, we create a root XMLListNode and add two
name tags to it. Because the XMLListNode has no internal
representation of its tag, it checks for matches in its
children. Note that you shouldn&#8217;t really create XML trees this
way; rather, you should always have an XMLDictNode as the
root. However, this shows the concept:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">badroot</span> <span class="o">=</span> <span class="n">XMLListNode</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">badroot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">XMLCDATANode</span><span class="p">(</span><span class="s1">&#39;tag #1&#39;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">badroot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">XMLCDATANode</span><span class="p">(</span><span class="s1">&#39;tag #2&#39;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">badroot</span>
<span class="go">[u&#39;tag #1&#39;, u&#39;tag #2&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">root</span><span class="o">.</span><span class="n">emit_xml</span><span class="p">()</span>
<span class="go">&lt;name&gt;tag #1&lt;/name&gt;</span>
<span class="go">&lt;name&gt;tag #2&lt;/name&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">badroot</span><span class="o">.</span><span class="n">find_nodes_with_tag</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">):</span>
<span class="gp">... </span>  <span class="nb">print</span> <span class="n">i</span>
<span class="gp">...</span>
<span class="go">tag #1</span>
<span class="go">tag #2</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Also, note that this method returns the actual node:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">jxmlease</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;          ... &lt;a&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;b&gt;</span>
<span class="gp">... </span><span class="s2">    &lt;c&gt;</span>
<span class="gp">... </span><span class="s2">      &lt;foo&gt;bar&lt;/foo&gt;</span>
<span class="gp">... </span><span class="s2">      &lt;status&gt;ok&lt;/status&gt;</span>
<span class="gp">... </span><span class="s2">    &lt;/c&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;/b&gt;</span>
<span class="gp">... </span><span class="s2">&lt;/a&gt;&quot;&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">find_nodes_with_tag</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">):</span>
<span class="gp">... </span>  <span class="nb">print</span> <span class="n">i</span>
<span class="gp">...</span>
<span class="go">{u&#39;c&#39;: {u&#39;foo&#39;: u&#39;bar&#39;, u&#39;status&#39;: u&#39;ok&#39;}}</span>
</pre></div>
</div>
</dd>
</dl>
<p>You can also use a tuple as the tag parameter, in which case
the method will return nodes with a tag that matches any of
the given tag values.</p>
<p>You can use this function to create somewhat complicated logic
that mimics the functionality from XPath &#8220;//tag&#8221; matches. For
example, here we check for &lt;xnm:warning&gt; and &lt;xnm:error&gt; nodes
and return their value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">jxmlease</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;          ... &lt;foo&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;xnm:warning&gt;</span>
<span class="gp">... </span><span class="s2">    &lt;message&gt;This is bad.&lt;/message&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;/xnm:warning&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;bar&gt;</span>
<span class="gp">... </span><span class="s2">    &lt;xnm:error&gt;</span>
<span class="gp">... </span><span class="s2">      &lt;message&gt;This is very bad.&lt;/message&gt;</span>
<span class="gp">... </span><span class="s2">    &lt;/xnm:error&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;/bar&gt;</span>
<span class="gp">... </span><span class="s2">&lt;/foot&gt;&quot;&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">has_node_with_tag</span><span class="p">((</span><span class="s1">&#39;xnm:warning&#39;</span><span class="p">,</span> <span class="s1">&#39;xnm:error&#39;</span><span class="p">)):</span>
<span class="gp">... </span>  <span class="nb">print</span> <span class="s2">&quot;Something bad happened.&quot;</span>
<span class="gp">...</span>
<span class="go">Something bad happened.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">find_nodes_with_tag</span><span class="p">((</span><span class="s1">&#39;xnm:warning&#39;</span><span class="p">,</span> <span class="s1">&#39;xnm:error&#39;</span><span class="p">)):</span>
<span class="gp">... </span>  <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;xnm:error&#39;</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">level</span> <span class="o">=</span> <span class="s2">&quot;Error:&quot;</span>
<span class="gp">... </span>  <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;xnm:warning&#39;</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">level</span> <span class="o">=</span> <span class="s2">&quot;Warning:&quot;</span>
<span class="gp">... </span>  <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">level</span> <span class="o">=</span> <span class="s2">&quot;Unknown:&quot;</span>
<span class="gp">... </span>  <span class="nb">print</span><span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;message&quot;</span><span class="p">,</span> <span class="s2">&quot;(unknown)&quot;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">Warning: This is bad.</span>
<span class="go">Error: This is very bad.</span>
</pre></div>
</div>
<p>Once a given node matches, the method does not check that
node&#8217;s children.</p>
<p>&#64;type tag: text or tuple
&#64;param tag: The XML tag (or tags) for which to search.
&#64;type recursive: bool
&#64;param key: If True (the default), search recursively through</p>
<blockquote>
<div>all children. If False, only search direct children.</div></blockquote>
<p>&#64;return: A generator which iterates over all matching nodes.</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.fromkeys">
<code class="descname">fromkeys</code><span class="sig-paren">(</span><em>S</em><span class="optional">[</span>, <em>v</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; New ordered dictionary with keys from S.<a class="headerlink" href="#jxmlease.XMLDictNode.fromkeys" title="Permalink to this definition">¶</a></dt>
<dd><p>If not specified, the value defaults to None.</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; D[k] if k in D, else d.  d defaults to None.<a class="headerlink" href="#jxmlease.XMLDictNode.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.get_cdata">
<code class="descname">get_cdata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.get_cdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a node&#8217;s CDATA.</p>
<p>&#64;rtype: text
&#64;return: The node&#8217;s CDATA.</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.get_current_node">
<code class="descname">get_current_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.get_current_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current node.</p>
<p>There are times that the current node must be replaced in the
XML tree for some reason. For example, due to the immutability
of Python strings, a new XMLCDATANode (which masquerades as a
string) is required anytime its CDATA value changes.</p>
<p>When this occurs, you can retrieve the latest node using the
get_current_node() method. This will attempt to find the node
that succeeded the node in question. If the node is still
current, it simply returns itself.</p>
<dl class="docutils">
<dt>Therefore, it should always be safe to run:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_current_node</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
<p>&#64;rtype: A subclass of XMLNodeBase
&#64;return: The current successor to the node (if</p>
<blockquote>
<div>any). If the node is still &#8220;current&#8221;, the method returns the
node itself.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.get_xml_attr">
<code class="descname">get_xml_attr</code><span class="sig-paren">(</span><em>attr</em>, <em>defval=&lt;jxmlease._NoArg instance&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.get_xml_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an XML attribute.</p>
<p>This method returns the value of an XML attribute.  If the XML
attribute does not exist, it will return a user-supplied
default value.  If the user did not supply a default value, it
raises a KeyError.</p>
<p>&#64;type attr: text
&#64;param attr: The name of the XML attribute.
&#64;type defval: text
&#64;param defval: The default value. (Default:</p>
<blockquote>
<div>Raise a KeyError.)</div></blockquote>
<p>&#64;return: The value of the XML attribute, or defval.
&#64;raises: KeyError, if the attr is not found and
defval is not supplied.</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.get_xml_attrs">
<code class="descname">get_xml_attrs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.get_xml_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the XML attribute dictionary.</p>
<p>This method returns the value of the XML attribute
dictonary.  Note that it returns the actual XML attribute
dictionary, rather than a copy.  Please take caution in
modifying it.</p>
<p>&#64;rtype: L{OrderedDict}
&#64;return: The XML attribute dictionary.</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.has_key">
<code class="descname">has_key</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span> &rarr; True if D has a key k, else False<a class="headerlink" href="#jxmlease.XMLDictNode.has_key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.has_node_with_tag">
<code class="descname">has_node_with_tag</code><span class="sig-paren">(</span><em>tag</em>, <em>recursive=True</em><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.has_node_with_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether a node with a matching tag exists.</p>
<p>This method uses the L{find_nodes_with_tag} method to search
for a node that is a child of the current node and has a
matching tag. The tag of the current node is not checked. The
method returns a boolean value to indicate whether at least
one matching node is found.</p>
<p>Because this function uses the L{find_nodes_with_tag} method,
the parameters and algorithm are the same as the
L{find_nodes_with_tag} method.</p>
<p>&#64;type tag: text or tuple
&#64;param tag: The XML tag (or tags) for which to search.
&#64;type recursive: bool
&#64;param key: If True (the default), search recursively through</p>
<blockquote>
<div>all children. If False, only search direct children.</div></blockquote>
<dl class="docutils">
<dt>&#64;return: True if at least one matching node is found;</dt>
<dd>otherwise, False.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.has_xml_attrs">
<code class="descname">has_xml_attrs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.has_xml_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the node has XML attributes.</p>
<p>&#64;rtype: boolean
&#64;return: True if the node has XML attributes; otherwise, False.</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; list of (key, value) pairs in od<a class="headerlink" href="#jxmlease.XMLDictNode.items" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.iteritems">
<code class="descname">iteritems</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.iteritems" title="Permalink to this definition">¶</a></dt>
<dd><p>od.iteritems -&gt; an iterator over the (key, value) pairs in od</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.iterkeys">
<code class="descname">iterkeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; an iterator over the keys in od<a class="headerlink" href="#jxmlease.XMLDictNode.iterkeys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.itervalues">
<code class="descname">itervalues</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.itervalues" title="Permalink to this definition">¶</a></dt>
<dd><p>od.itervalues -&gt; an iterator over the values in od</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.jdict">
<code class="descname">jdict</code><span class="sig-paren">(</span><em>in_place=False</em>, <em>promote=False</em><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.jdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary keyed appropriately for Junos output.</p>
<p>This method is a shortcut to call the L{dict} method with these
:param - attrs=[(&#8216;junos: key&#8217;, &#8216;junos:key&#8217;, &#8216;junos:key&#8217;),</p>
<blockquote>
<div>(&#8216;junos:key&#8217;, &#8216;junos:key&#8217;), &#8216;junos:key&#8217;]</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tags=['name']</strong> (<em>-</em>) &#8211; </td>
</tr>
</tbody>
</table>
<p>This will attempt to produce the correct key for each
node. Some nodes have a multi-field key. If that occurs, the
dictionary key will be a tuple. In cases where there is a
single key, the dictionary key will be a string. If there is
no matching node, the key will simply be the XML tag name.</p>
<p>Some Junos nodes use a different tag for the key. And, in some
cases, the junos:key attribute is not available. In those
circumstances, you should directly call the L{dict} method
with the correct attributes or tags.</p>
<p>Please see the documentation for the L{dict} method for
further information.</p>
<p>&#64;type in_place: bool
&#64;param in_place: Whether the change should be made in the XML</p>
<blockquote>
<div>tree.</div></blockquote>
<p>&#64;type promote: bool
&#64;param promote: Whether the new nodes should be added to a</p>
<blockquote>
<div>dictonary placed at the current node, or they should be
&#8220;promoted&#8221; to the first enclosing dictionary.</div></blockquote>
<p>&#64;rtype: L{XMLDictNode}
&#64;return: If in_place is False, a dictionary formulated from</p>
<blockquote>
<div>the current node. If in_place is True, the dictionary to which
the nodes were added. (Note: If promote is True, this
dictionary may contain additional entries that already
existed in the enclosing dictionary.)</div></blockquote>
<dl class="docutils">
<dt>&#64;raises: AttributeError, if the node is out of date and</dt>
<dd>in_place is True. (See L{get_current_node}.)</dd>
<dt>&#64;raises: AttributeError, if in_place is True and the method</dt>
<dd>encounters irrecoverable data inconsistency while making
changes to the XML tree.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; list of keys in od<a class="headerlink" href="#jxmlease.XMLDictNode.keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.list">
<code class="descname">list</code><span class="sig-paren">(</span><em>in_place=False</em><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a node as a list.</p>
<p>This method returns a node as a list. This is useful when you
are not sure whether a node will contain a single entry or a
list. If the node contains a list, the node itself is
returned. If the node does not already contain a list, the
method creates a list, adds the node to it, and returns the
list.</p>
<p>If the in_place parameter is True, then the change is made in
the XML tree. Otherwise, the XML tree is left unchanged and
the method creates and returns a temporary list.</p>
<p>&#64;type in_place: bool
&#64;param in_place: Whether the change should be made in the XML</p>
<blockquote>
<div>tree.</div></blockquote>
<p>&#64;rtype: list or L{XMLListNode}
&#64;return: If the current node is a list, the current node;</p>
<blockquote>
<div>otherwise, a list containing the current node as its sole
member.</div></blockquote>
<dl class="docutils">
<dt>&#64;raises: AttributeError, if the node is out of date and</dt>
<dd>in_place is True. (See L{get_current_node}.)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; v, remove specified key and return the corresponding<a class="headerlink" href="#jxmlease.XMLDictNode.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>value.  If key is not found, d is returned if given, otherwise KeyError
is raised.</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; (k, v), return and remove a (key, value) pair.<a class="headerlink" href="#jxmlease.XMLDictNode.popitem" title="Permalink to this definition">¶</a></dt>
<dd><p>Pairs are returned in LIFO order if last is true or FIFO order if false.</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.prettyprint">
<code class="descname">prettyprint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/jxmlease.html#XMLDictNode.prettyprint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#jxmlease.XMLDictNode.prettyprint" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a &#8220;pretty&#8221; representation of the data structure.</p>
<p>This uses the Python pprint method to print a &#8220;pretty&#8221;
representation of the data structure. The parameters are
passed unchanged to the Python pprint method.</p>
<p>This shows only the main data and not the meta data (such as
XML attributes).</p>
<p>When using pprint, it is necessary to use this method to get a
reasonable representation of the data; otherwise, pprint will
not know how to represent the object in a &#8220;pretty&#8221; way.</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.set_cdata">
<code class="descname">set_cdata</code><span class="sig-paren">(</span><em>cdata</em>, <em>return_node=False</em><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.set_cdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a node&#8217;s CDATA.</p>
<p>This method sets a node&#8217;s CDATA.  Note that any node can
contain CDATA in what is called &#8220;semi-structured&#8221;
XML. However, nodes that only contain CDATA are represented as
L{XMLCDATANode} objects. Regardless of the node, you can use
this same method to set the CDATA.</p>
<p>B{Note}: When running this on an XMLCDATANode, the actual node
will be replaced with a new node in the tree. (This is a
result of Python&#8217;s string immutability.)  The function will
update the XML tree, if necessary; however, any local
references you have saved for the node will become stale.  You
can obtain the updated node by setting the return_node
parameter to True or by running the L{get_current_node} method
on the old node. For this reason, if you plan to keep a local
reference to XML node in question, it is a good idea to run
the method like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">set_cdata</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>&#64;type cdata: text
&#64;param cdata: The text value that should be used for the</p>
<blockquote>
<div>node&#8217;s CDATA.</div></blockquote>
<p>&#64;type return_node: bool
&#64;param return_node: Whether the method should return the</p>
<blockquote>
<div>updated node.</div></blockquote>
<p>&#64;rtype: None or an appropriate node object.
&#64;return: If return_node is False, None; otherwise, the updated</p>
<blockquote>
<div>node object.</div></blockquote>
<dl class="docutils">
<dt>&#64;raises: AttributeError, if the node is out of date. (See</dt>
<dd>L{get_current_node}.)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.set_xml_attr">
<code class="descname">set_xml_attr</code><span class="sig-paren">(</span><em>attr</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.set_xml_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set an XML attribute.</p>
<p>This method sets the XML attribute to the given value.  If the
XML attribute already existed, its value is overridden by the
new value.  If the XML attribute did not already exist, it is
created.</p>
<p>&#64;type attr: text
&#64;param attr: The name of the XML attribute.
&#64;type val: text
&#64;param val: The value of the XML attribute.
&#64;rtype: None
&#64;return: None
&#64;raises: AttributeError, if the node is out of date. (See</p>
<blockquote>
<div>L{get_current_node}.)</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.setdefault">
<code class="descname">setdefault</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; od.get(k,d), also set od[k]=d if k not in od<a class="headerlink" href="#jxmlease.XMLDictNode.setdefault" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.standardize">
<code class="descname">standardize</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/jxmlease.html#XMLDictNode.standardize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#jxmlease.XMLDictNode.standardize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert all child nodes to instances of an L{XMLNodeBase} sub-class.</p>
<p>This method is useful when you have added a child node
directly to a dictionary or list and now want to convert it to
the appropriate L{XMLNodeBase} sub-class.</p>
<p>&#64;type deep: bool
&#64;param deep: If True (the default), recursively descend</p>
<blockquote>
<div>through all children, converting all nodes, as needed. If
False, only convert direct children of the node.</div></blockquote>
<p>&#64;return: None</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.strip_cdata">
<code class="descname">strip_cdata</code><span class="sig-paren">(</span><em>chars=None</em>, <em>return_node=False</em><span class="sig-paren">)</span><a class="headerlink" href="#jxmlease.XMLDictNode.strip_cdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Strip leading/trailing characters from a node&#8217;s CDATA.</p>
<p>This method runs the string class&#8217; strip() method on a node&#8217;s
CDATA and updates the node&#8217;s CDATA with the result. (This is
the functional equivalent to
node.set_cdata(node.get_cdata().strip()).)</p>
<p>Note that any node can contain CDATA in what is called
&#8220;semi-structured&#8221; XML. However, nodes that only contain CDATA
are represented as L{XMLCDATANode} objects. Regardless of the
node, you can use this same method to append CDATA.</p>
<p>B{Note}: When running this on an XMLCDATANode, the actual node
will be replaced with a new node in the tree. (This is a
result of Python&#8217;s string immutability.)  The function will
update the XML tree, if necessary; however, any local
references you have saved for the node will become stale.  You
can obtain the updated node by setting the return_node
parameter to True or by running the L{get_current_node} method
on the old node. For this reason, if you plan to keep a local
reference to XML node in question, it is a good idea to run
the method like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">strip_cdata</span><span class="p">(</span><span class="n">return_node</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>&#64;type chars: text
&#64;param chars: A string containing the characters to</p>
<blockquote>
<div>strip. This is passed to the string class&#8217; strip() method.</div></blockquote>
<p>&#64;type return_node: bool
&#64;param return_node: Whether the method should return the</p>
<blockquote>
<div>updated node.</div></blockquote>
<p>&#64;rtype: None or an appropriate node object.
&#64;return: If return_node is False, None; otherwise, the updated</p>
<blockquote>
<div>node object.</div></blockquote>
<dl class="docutils">
<dt>&#64;raises: AttributeError, if the node is out of date. (See</dt>
<dd>L{get_current_node}.)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em>E</em>, <span class="optional">]</span><em>**F</em><span class="sig-paren">)</span> &rarr; None.  Update D from mapping/iterable E and F.<a class="headerlink" href="#jxmlease.XMLDictNode.update" title="Permalink to this definition">¶</a></dt>
<dd><p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v</p>
</dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; list of values in od<a class="headerlink" href="#jxmlease.XMLDictNode.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.viewitems">
<code class="descname">viewitems</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; a set-like object providing a view on od's items<a class="headerlink" href="#jxmlease.XMLDictNode.viewitems" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.viewkeys">
<code class="descname">viewkeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; a set-like object providing a view on od's keys<a class="headerlink" href="#jxmlease.XMLDictNode.viewkeys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="jxmlease.XMLDictNode.viewvalues">
<code class="descname">viewvalues</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; an object providing a view on od's values<a class="headerlink" href="#jxmlease.XMLDictNode.viewvalues" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/juniper_logo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="parsing.html" title="previous chapter">Parsing XML</a></li>
      <li>Next: <a href="iteration.html" title="next chapter">Iteration</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Juniper Networks.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>