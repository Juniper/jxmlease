<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>jxmlease &mdash; jxmlease 0.0.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="jxmlease 0.0.1 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for jxmlease</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># Copyright (c) 2015, Juniper Networks, Inc.</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2012 Martin Blech and individual contributors.</span>
<span class="c1">#</span>
<span class="c1"># See the LICENSE file for further information.</span>
<span class="sd">&quot;&quot;&quot;jxmlease converts between XML and intelligent Python data structures.</span>

<span class="sd">For a quick start, you can use the :py:meth:`parse` method to convert a</span>
<span class="sd">block of XML to a Python data structure. This example parses ``xml`` and uses</span>
<span class="sd">the :py:meth:`XMLDictNode.prettyprint` method to display the result::</span>

<span class="sd">    &gt;&gt;&gt; xml = &quot;&lt;a&gt;&lt;b&gt;&lt;c&gt;foo&lt;/c&gt;&lt;c&gt;bar&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&quot;</span>
<span class="sd">    &gt;&gt;&gt; parse(xml).prettyprint()</span>
<span class="sd">    {u&#39;a&#39;: {u&#39;b&#39;: {u&#39;c&#39;: [u&#39;foo&#39;, u&#39;bar&#39;]}}}</span>

<span class="sd">Or, you can use the :py:class:`XMLDictNode` class to convert a Python data</span>
<span class="sd">structure to an intelligent XML data structure. The following example creates an</span>
<span class="sd">:py:obj:`XMLDictNode` object from ``data_structure`` and outputs the resulting</span>
<span class="sd">XML using the :py:meth:`XMLNodeBase.emit_xml` method::</span>

<span class="sd">    &gt;&gt;&gt; data_structure = {u&#39;a&#39;: {u&#39;b&#39;: {u&#39;c&#39;: [u&#39;foo&#39;, u&#39;bar&#39;]}}}</span>
<span class="sd">    &gt;&gt;&gt; print XMLDictNode(data_structure).emit_xml()</span>
<span class="sd">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="sd">    &lt;a&gt;</span>
<span class="sd">        &lt;b&gt;</span>
<span class="sd">            &lt;c&gt;foo&lt;/c&gt;</span>
<span class="sd">            &lt;c&gt;bar&lt;/c&gt;</span>
<span class="sd">        &lt;/b&gt;</span>
<span class="sd">    &lt;/a&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">xml.parsers</span> <span class="kn">import</span> <span class="n">expat</span>
<span class="kn">from</span> <span class="nn">xml.sax.saxutils</span> <span class="kn">import</span> <span class="n">XMLGenerator</span>
<span class="kn">from</span> <span class="nn">xml.sax.xmlreader</span> <span class="kn">import</span> <span class="n">AttributesImpl</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
<span class="k">try</span><span class="p">:</span>  <span class="c1"># pragma no cover</span>
    <span class="kn">from</span> <span class="nn">cStringIO</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># pragma no cover</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">StringIO</span> <span class="kn">import</span> <span class="n">StringIO</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="k">try</span><span class="p">:</span> <span class="c1"># pragma no cover</span>
    <span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span> <span class="c1"># pragma no cover</span>
    <span class="n">BytesIO</span> <span class="o">=</span> <span class="n">StringIO</span>
<span class="k">try</span><span class="p">:</span>  <span class="c1"># pragma no cover</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span> <span class="k">as</span> <span class="n">_OrderedDict</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># pragma no cover</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">ordereddict</span> <span class="kn">import</span> <span class="n">OrderedDict</span> <span class="k">as</span> <span class="n">_OrderedDict</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">_OrderedDict</span> <span class="o">=</span> <span class="nb">dict</span>
<span class="k">try</span><span class="p">:</span> <span class="c1"># pragma no cover</span>
    <span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span> <span class="c1"># pragma no cover</span>
    <span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;stream&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stream</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">obj</span><span class="p">)</span>

<span class="n">QNameDecode</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">try</span><span class="p">:</span> <span class="c1"># pragma no cover</span>
    <span class="kn">from</span> <span class="nn">lxml</span> <span class="kn">import</span> <span class="n">etree</span>
    <span class="n">QNameDecode</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">QName</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span> <span class="c1"># pragma no cover</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">xml.etree.cElementTree</span> <span class="kn">as</span> <span class="nn">etree</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">as</span> <span class="nn">etree</span>
            <span class="c1"># Not tested; but, should be the same as cElementTree</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">cElementTree</span> <span class="kn">as</span> <span class="nn">etree</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Warning: Not tested with cElementTree&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="kn">import</span> <span class="nn">elementtree.ElementTree</span> <span class="kn">as</span> <span class="nn">etree</span>
                    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Warning: Not tested with elementtree.ElementTree&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Unable to import etree: lxml functionality disabled&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">QNameSeparator</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">endidx</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;}&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;{&#39;</span> <span class="ow">or</span> <span class="n">endidx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">localname</span> <span class="o">=</span> <span class="n">text</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">endidx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">localname</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">endidx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

<span class="k">if</span> <span class="n">etree</span> <span class="ow">and</span> <span class="n">QNameDecode</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="c1"># pragma no cover</span>
    <span class="k">class</span> <span class="nc">QNameDecode</span><span class="p">(</span><span class="n">QNameSeparator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="n">QNameSeparator</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>  <span class="c1"># pragma no cover</span>
    <span class="n">_basestring</span> <span class="o">=</span> <span class="nb">basestring</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>  <span class="c1"># pragma no cover</span>
    <span class="n">_basestring</span> <span class="o">=</span> <span class="nb">str</span>
<span class="k">try</span><span class="p">:</span>  <span class="c1"># pragma no cover</span>
    <span class="n">_unicode</span> <span class="o">=</span> <span class="nb">unicode</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>  <span class="c1"># pragma no cover</span>
    <span class="n">_unicode</span> <span class="o">=</span> <span class="nb">str</span>
<span class="k">try</span><span class="p">:</span>  <span class="c1"># pragma no cover</span>
    <span class="n">_bytes</span> <span class="o">=</span> <span class="nb">bytes</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>  <span class="c1"># pragma no cover</span>
    <span class="n">_bytes</span> <span class="o">=</span> <span class="nb">str</span>

<span class="c1"># While doing processing for a generator, process XML text 1KB at a</span>
<span class="c1"># time.</span>
<span class="n">parsing_increment</span> <span class="o">=</span> <span class="mi">1024</span>

<span class="c1"># A user can use this to set their custom defaults for parsers.</span>
<span class="n">parser_defaults</span> <span class="o">=</span> <span class="p">{}</span>


<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Jonathan Looney&#39;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s1">&#39;0.0.1&#39;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s1">&#39;MIT&#39;</span>

<span class="k">class</span> <span class="nc">_NoArg</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Internal Use Only&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">OrderedDict</span><span class="p">(</span><span class="n">_OrderedDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Standard OrderedDict class, with a small local modification.</span>

<span class="sd">    This module uses the OrderedDict class to maintain ordering</span>
<span class="sd">    of the input data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_repr_running</span><span class="o">=</span><span class="p">{}):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># The OrderedDict.__repr__ function takes an</span>
            <span class="c1"># extra argument. It also prints the name of</span>
            <span class="c1"># the main object&#39;s class. This logic temporarily</span>
            <span class="c1"># resets the class name so this appears to be</span>
            <span class="c1"># what it (fundamentally) is: an OrderedDict</span>
            <span class="c1"># object. (For this reason, there is also extra</span>
            <span class="c1"># logic to make the XMLDictNode __repr__ function</span>
            <span class="c1"># work correctly.)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">_OrderedDict</span><span class="o">.</span><span class="n">__name__</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">_OrderedDict</span><span class="o">.</span><span class="n">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_repr_running</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">_OrderedDict</span><span class="o">.</span><span class="n">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">temp</span>
        <span class="k">return</span> <span class="n">rv</span>

<span class="k">class</span> <span class="nc">_XMLNodeMetaClass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Internal Use Only&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="c1"># Record parent class for later use.</span>
        <span class="nb">dict</span><span class="p">[</span><span class="s2">&quot;__parent_class__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bases</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Handle doc string inheritance. This is all a fancy way of</span>
        <span class="c1"># inheriting doc strings from earlier classes. It will only</span>
        <span class="c1"># overwrite doc strings if they are not already set.</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">__doc__</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">XMLNodeBase</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                        <span class="nb">dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">XMLNodeBase</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">__doc__</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">if</span> <span class="s1">&#39;__init__&#39;</span> <span class="ow">in</span> <span class="nb">dict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">[</span><span class="s1">&#39;__init__&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">__doc__</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">[</span><span class="s1">&#39;__init__&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Initialize an </span><span class="si">%s</span><span class="s2"> object.</span>
<span class="s2">            </span>
<span class="s2">            See the class documentation for initializer arguments.</span>
<span class="s2">            &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;__doc__&#39;</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">[</span><span class="s1">&#39;__doc__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Initialize an </span><span class="si">%s</span><span class="s2"> object.</span>
<span class="s2">            </span>
<span class="s2">            The optional first parameter can be the value to which the</span>
<span class="s2">            object should be initialized. All other parameters must be</span>
<span class="s2">            given as keywords.</span>
<span class="s2">            </span>
<span class="s2">            Normally, the user can simply run this as::</span>

<span class="s2">                &gt;&gt;&gt; node = </span><span class="si">%s</span><span class="s2">(initializer)</span>
<span class="s2">            </span>
<span class="s2">            In fact, the best way to use this is::</span>

<span class="s2">                &gt;&gt;&gt; root = XMLDictNode({&#39;root&#39;: {&#39;branch&#39;: { &#39;leaf&#39;: &#39;a&#39;}}})</span>
<span class="s2">            </span>
<span class="s2">            That will set all the tags, keys, etc. correctly. However,</span>
<span class="s2">            if you really want to customize a node, there are other</span>
<span class="s2">            parameters available. Note that these parameters only</span>
<span class="s2">            impact *this* node and descendants. They don&#39;t actually</span>
<span class="s2">            add the node to a tree. Therefore, their use is</span>
<span class="s2">            discouraged. Instead, you can probably use the :py:meth:`add_node`</span>
<span class="s2">            method to build your tree correctly.</span>
<span class="s2">            </span>
<span class="s2">            The one exception to this general rule is when adding a</span>
<span class="s2">            hunk of a tree. For example, assume you currently have this XML</span>
<span class="s2">            structure::</span>

<span class="s2">                &lt;a&gt;</span>
<span class="s2">                  &lt;b&gt;</span>
<span class="s2">                    &lt;node1&gt;a&lt;/node1&gt;</span>
<span class="s2">                  &lt;/b&gt;</span>
<span class="s2">                &lt;/a&gt;</span>
<span class="s2">            </span>
<span class="s2">            And, assume you want to add another node ``b`` to create this</span>
<span class="s2">            XML structure::</span>

<span class="s2">                &lt;a&gt;</span>
<span class="s2">                  &lt;b&gt;</span>
<span class="s2">                    &lt;node1&gt;a&lt;/node1&gt;</span>
<span class="s2">                  &lt;/b&gt;</span>
<span class="s2">                  &lt;b&gt;</span>
<span class="s2">                    &lt;node2&gt;b&lt;/node1&gt;</span>
<span class="s2">                  &lt;/b&gt;</span>
<span class="s2">                &lt;/a&gt;</span>
<span class="s2">            </span>
<span class="s2">            In that case, you might do something like this::</span>

<span class="s2">                &gt;&gt;&gt; root.prettyprint()</span>
<span class="s2">                {u&#39;a&#39;: {u&#39;b&#39;: {u&#39;node1&#39;: u&#39;a&#39;}}}</span>
<span class="s2">                &gt;&gt;&gt; new_b = {&#39;node2&#39;: &#39;b&#39;}</span>
<span class="s2">                &gt;&gt;&gt; new_b = XMLDictNode(new_b, tag=&quot;b&quot;)</span>
<span class="s2">                &gt;&gt;&gt; _ = root[&#39;a&#39;].add_node(tag=&quot;b&quot;, new_node=new_b)</span>
<span class="s2">                &gt;&gt;&gt; root.prettyprint()</span>
<span class="s2">                {u&#39;a&#39;: {u&#39;b&#39;: [{u&#39;node1&#39;: u&#39;a&#39;}, {&#39;node2&#39;: u&#39;b&#39;}]}}</span>
<span class="s2">            </span>
<span class="s2">            And, you can print the XML to prove it is formatted correctly::</span>

<span class="s2">                &gt;&gt;&gt; print root.emit_xml()</span>
<span class="s2">                &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="s2">                &lt;a&gt;</span>
<span class="s2">                    &lt;b&gt;</span>
<span class="s2">                        &lt;node1&gt;a&lt;/node1&gt;</span>
<span class="s2">                    &lt;/b&gt;</span>
<span class="s2">                    &lt;b&gt;</span>
<span class="s2">                        &lt;node2&gt;b&lt;/node2&gt;</span>
<span class="s2">                    &lt;/b&gt;</span>
<span class="s2">                &lt;/a&gt;</span>
<span class="s2">            </span>
<span class="s2">            Args:</span>
<span class="s2">                initializer (as appropriate for node): The initial value for</span>
<span class="s2">                    the node.</span>
<span class="s2">                tag (string): The XML tag for this node.</span>
<span class="s2">                key (text or tuple): The dictionary key used for this node.</span>
<span class="s2">                xml_attrs (dict): The XML attributes for the node.</span>
<span class="s2">              </span>
<span class="s2">              @type text: text</span>
<span class="s2">              @param text: The node&#39;s initial CDATA value. (Note</span>
<span class="s2">                  that this is ignored for XMLCDATANode objects.)</span>
<span class="s2">              </span>
<span class="s2">              @type parent: An instance of a sub-class of L{XMLNodeBase}</span>
<span class="s2">              @param parent: A reference to the object&#39;s parent</span>
<span class="s2">                  node in the data structure.</span>
<span class="s2">              </span>
<span class="s2">              @type convert: bool</span>
<span class="s2">              @param convert: If True, the L{convert} method is run on</span>
<span class="s2">                  the object&#39;s children during object initialization.</span>
<span class="s2">              </span>
<span class="s2">              @type deep: bool</span>
<span class="s2">              @param deep: If True (and the convert parameter is</span>
<span class="s2">                  True), the L{convert} method is run recursively</span>
<span class="s2">                  on the object&#39;s children during object initialization.</span>
<span class="s2">            &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># Create and return the class.</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Determine if we were called with an initial value. If so,</span>
        <span class="c1"># make sure there was only *one* initial value.</span>
        <span class="n">initializer</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;initializer&quot;</span><span class="p">,</span> <span class="n">_NoArg</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initializer</span><span class="p">,</span> <span class="n">_NoArg</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;got multiple values for keyword argument &#39;initializer&#39;&quot;</span><span class="p">)</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">initializer</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">initializer</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


        <span class="c1"># Process arguments</span>

        <span class="c1"># Do not inherit tag, key, or parent in copies.</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
        <span class="n">parent_node</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="c1"># If the initial value was an XMLNodeBase child, copy</span>
        <span class="c1"># node_text and xml_attrs.</span>

        <span class="c1"># Set some overall defaults</span>
        <span class="n">xml_attrs</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">node_text</span> <span class="o">=</span> <span class="n">_unicode</span><span class="p">()</span>

        <span class="c1"># Modify the defaults if the initial value was an XMLNodeBase object</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initializer</span><span class="p">,</span> <span class="n">XMLNodeBase</span><span class="p">):</span>
            <span class="n">xml_attrs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">initializer</span><span class="p">,</span> <span class="s2">&quot;xml_attrs&quot;</span><span class="p">,</span> <span class="n">xml_attrs</span><span class="p">)</span>
            <span class="n">node_text</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">initializer</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="n">node_text</span><span class="p">)</span>

        <span class="c1"># Process the arguments to override the defaults</span>
        <span class="n">xml_attrs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;xml_attrs&quot;</span><span class="p">,</span> <span class="n">xml_attrs</span><span class="p">)</span>
        <span class="n">node_text</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="n">node_text</span><span class="p">)</span>

        <span class="c1"># Process other arguments</span>
        <span class="n">convert</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;convert&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">deep</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;deep&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="c1"># Create the object.</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Add attributes to the object.</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">xml_attrs</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xml_attrs</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">xml_attrs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unicode</span><span class="p">(</span><span class="n">xml_attrs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">):</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">node_text</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent_node</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_replacement_node</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">convert</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>


<span class="c1"># The below is Python 2/3 Portable equivalent to</span>
<span class="c1">#   class XMLNodeMetaClass(object, metaclass=_XMLNodeMetaClass):</span>
<span class="c1">#       pass</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
    <span class="n">_temp_class_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;__module__&#39;</span><span class="p">:</span> <span class="n">_XMLNodeMetaClass</span><span class="o">.</span><span class="n">__module__</span><span class="p">,</span>
                        <span class="s1">&#39;__qualname__&#39;</span><span class="p">:</span> <span class="s1">&#39;XMLNodeMetaClass&#39;</span><span class="p">}</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">_temp_class_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;__module__&#39;</span><span class="p">:</span> <span class="n">_XMLNodeMetaClass</span><span class="o">.</span><span class="n">__module__</span><span class="p">,</span>
                        <span class="s1">&#39;__metaclass__&#39;</span><span class="p">:</span> <span class="n">_XMLNodeMetaClass</span><span class="p">}</span>

<span class="n">XMLNodeMetaClass</span> <span class="o">=</span> <span class="n">_XMLNodeMetaClass</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="s2">&quot;XMLNodeMetaClass&quot;</span><span class="p">),</span>
                                     <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="n">_temp_class_dict</span><span class="p">)</span>

<span class="k">del</span> <span class="n">_temp_class_dict</span>

<span class="k">class</span> <span class="nc">XMLNodeBase</span><span class="p">(</span><span class="n">XMLNodeMetaClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This module provides methods common to the XML node classes.</span>
<span class="sd">    </span>
<span class="sd">    This modules is not intended for standalone use.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">has_xml_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine if the node has XML attributes.</span>
<span class="sd">        </span>
<span class="sd">        @rtype: boolean</span>
<span class="sd">        @return: True if the node has XML attributes; otherwise, False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xml_attrs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_check_replacement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Ensure the object is current.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replacement_node</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Attempt to modify an out-of-date node. &quot;</span> <span class="o">+</span>
                <span class="s2">&quot;Use get_current_node() to update the reference.&quot;</span>
                <span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">set_xml_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set an XML attribute.</span>
<span class="sd">        </span>
<span class="sd">        This method sets the XML attribute to the given value.  If the</span>
<span class="sd">        XML attribute already existed, its value is overridden by the</span>
<span class="sd">        new value.  If the XML attribute did not already exist, it is</span>
<span class="sd">        created.</span>
<span class="sd">        </span>
<span class="sd">        @type attr: text</span>
<span class="sd">        @param attr: The name of the XML attribute.</span>
<span class="sd">        @type val: text</span>
<span class="sd">        @param val: The value of the XML attribute.</span>
<span class="sd">        @rtype: None</span>
<span class="sd">        @return: None</span>
<span class="sd">        @raises: AttributeError, if the node is out of date. (See</span>
<span class="sd">            L{get_current_node}.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xml_attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unicode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_xml_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">defval</span><span class="o">=</span><span class="n">_NoArg</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;Get an XML attribute.</span>
<span class="sd">        </span>
<span class="sd">        This method returns the value of an XML attribute.  If the XML</span>
<span class="sd">        attribute does not exist, it will return a user-supplied</span>
<span class="sd">        default value.  If the user did not supply a default value, it</span>
<span class="sd">        raises a KeyError.</span>
<span class="sd">        </span>
<span class="sd">        @type attr: text</span>
<span class="sd">        @param attr: The name of the XML attribute.</span>
<span class="sd">        @type defval: text</span>
<span class="sd">        @param defval: The default value. (Default:</span>
<span class="sd">            Raise a KeyError.)</span>
<span class="sd">        @return: The value of the XML attribute, or defval.</span>
<span class="sd">        @raises: KeyError, if the attr is not found and</span>
<span class="sd">        defval is not supplied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xml_attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">defval</span><span class="p">,</span> <span class="n">_NoArg</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">defval</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">get_xml_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the XML attribute dictionary.</span>
<span class="sd">        </span>
<span class="sd">        This method returns the value of the XML attribute</span>
<span class="sd">        dictonary.  Note that it returns the actual XML attribute</span>
<span class="sd">        dictionary, rather than a copy.  Please take caution in</span>
<span class="sd">        modifying it.</span>
<span class="sd">        </span>
<span class="sd">        @rtype: L{OrderedDict}</span>
<span class="sd">        @return: The XML attribute dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xml_attrs</span>

    <span class="k">def</span> <span class="nf">delete_xml_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete an XML attribute.</span>
<span class="sd">        </span>
<span class="sd">        This method deletes an XML attribute from the node.  If the</span>
<span class="sd">        attribute does not exist, it raises a KeyError.</span>
<span class="sd">        </span>
<span class="sd">        @type attr: text</span>
<span class="sd">        @param attr: The name of the XML attribute.</span>
<span class="sd">        @return: None</span>
<span class="sd">        @raises: KeyError, if the attr is not found.</span>
<span class="sd">        @raises: AttributeError, if the node is out of date. (See</span>
<span class="sd">            L{get_current_node}.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">xml_attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_cdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">return_node</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a node&#39;s CDATA.</span>
<span class="sd">        </span>
<span class="sd">        This method sets a node&#39;s CDATA.  Note that any node can</span>
<span class="sd">        contain CDATA in what is called &quot;semi-structured&quot;</span>
<span class="sd">        XML. However, nodes that only contain CDATA are represented as</span>
<span class="sd">        L{XMLCDATANode} objects. Regardless of the node, you can use</span>
<span class="sd">        this same method to set the CDATA.</span>
<span class="sd">        </span>
<span class="sd">        B{Note}: When running this on an XMLCDATANode, the actual node</span>
<span class="sd">        will be replaced with a new node in the tree. (This is a</span>
<span class="sd">        result of Python&#39;s string immutability.)  The function will</span>
<span class="sd">        update the XML tree, if necessary; however, any local</span>
<span class="sd">        references you have saved for the node will become stale.  You</span>
<span class="sd">        can obtain the updated node by setting the return_node</span>
<span class="sd">        parameter to True or by running the L{get_current_node} method</span>
<span class="sd">        on the old node. For this reason, if you plan to keep a local</span>
<span class="sd">        reference to XML node in question, it is a good idea to run</span>
<span class="sd">        the method like this:</span>
<span class="sd">          &gt;&gt;&gt; node = root[&#39;a&#39;][&#39;b&#39;][0]</span>
<span class="sd">          &gt;&gt;&gt; node = node.set_cdata(&quot;foo&quot;, True)</span>
<span class="sd">        </span>
<span class="sd">        @type cdata: text</span>
<span class="sd">        @param cdata: The text value that should be used for the</span>
<span class="sd">            node&#39;s CDATA.</span>
<span class="sd">        @type return_node: bool</span>
<span class="sd">        @param return_node: Whether the method should return the</span>
<span class="sd">            updated node.</span>
<span class="sd">        @rtype: None or an appropriate node object.</span>
<span class="sd">        @return: If return_node is False, None; otherwise, the updated</span>
<span class="sd">            node object.</span>
<span class="sd">        @raises: AttributeError, if the node is out of date. (See</span>
<span class="sd">            L{get_current_node}.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">_unicode</span><span class="p">(</span><span class="n">cdata</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_node</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">append_cdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">return_node</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append text to a node&#39;s CDATA.</span>
<span class="sd">        </span>
<span class="sd">        This method appends text to a node&#39;s CDATA.  Note that any</span>
<span class="sd">        node can contain CDATA in what is called &quot;semi-structured&quot;</span>
<span class="sd">        XML. However, nodes that only contain CDATA are represented as</span>
<span class="sd">        L{XMLCDATANode} objects. Regardless of the node, you can use</span>
<span class="sd">        this same method to append CDATA.</span>
<span class="sd">        </span>
<span class="sd">        B{Note}: When running this on an XMLCDATANode, the actual node</span>
<span class="sd">        will be replaced with a new node in the tree. (This is a</span>
<span class="sd">        result of Python&#39;s string immutability.)  The function will</span>
<span class="sd">        update the XML tree, if necessary; however, any local</span>
<span class="sd">        references you have saved for the node will become stale.  You</span>
<span class="sd">        can obtain the updated node by setting the return_node</span>
<span class="sd">        parameter to True or by running the L{get_current_node} method</span>
<span class="sd">        on the old node. For this reason, if you plan to keep a local</span>
<span class="sd">        reference to XML node in question, it is a good idea to run</span>
<span class="sd">        the method like this:</span>
<span class="sd">          &gt;&gt;&gt; node = root[&#39;a&#39;][&#39;b&#39;][0]</span>
<span class="sd">          &gt;&gt;&gt; node = node.append_cdata(&quot;foo&quot;, True)</span>
<span class="sd">        </span>
<span class="sd">        @type cdata: text</span>
<span class="sd">        @param cdata: The text value that should be used for the</span>
<span class="sd">            node&#39;s CDATA.</span>
<span class="sd">        @type return_node: bool</span>
<span class="sd">        @param return_node: Whether the method should return the</span>
<span class="sd">            updated node.</span>
<span class="sd">        @rtype: None or an appropriate node object.</span>
<span class="sd">        @return: If return_node is False, None; otherwise, the updated</span>
<span class="sd">            node object.</span>
<span class="sd">        @raises: AttributeError, if the node is out of date. (See</span>
<span class="sd">            L{get_current_node}.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">+</span> <span class="n">cdata</span>
        <span class="k">if</span> <span class="n">return_node</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">get_cdata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a node&#39;s CDATA.</span>
<span class="sd">        </span>
<span class="sd">        @rtype: text</span>
<span class="sd">        @return: The node&#39;s CDATA.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span>

    <span class="k">def</span> <span class="nf">strip_cdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">return_node</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Strip leading/trailing characters from a node&#39;s CDATA.</span>
<span class="sd">        </span>
<span class="sd">        This method runs the string class&#39; strip() method on a node&#39;s</span>
<span class="sd">        CDATA and updates the node&#39;s CDATA with the result. (This is</span>
<span class="sd">        the functional equivalent to</span>
<span class="sd">        node.set_cdata(node.get_cdata().strip()).)</span>
<span class="sd">        </span>
<span class="sd">        Note that any node can contain CDATA in what is called</span>
<span class="sd">        &quot;semi-structured&quot; XML. However, nodes that only contain CDATA</span>
<span class="sd">        are represented as L{XMLCDATANode} objects. Regardless of the</span>
<span class="sd">        node, you can use this same method to append CDATA.</span>
<span class="sd">        </span>
<span class="sd">        B{Note}: When running this on an XMLCDATANode, the actual node</span>
<span class="sd">        will be replaced with a new node in the tree. (This is a</span>
<span class="sd">        result of Python&#39;s string immutability.)  The function will</span>
<span class="sd">        update the XML tree, if necessary; however, any local</span>
<span class="sd">        references you have saved for the node will become stale.  You</span>
<span class="sd">        can obtain the updated node by setting the return_node</span>
<span class="sd">        parameter to True or by running the L{get_current_node} method</span>
<span class="sd">        on the old node. For this reason, if you plan to keep a local</span>
<span class="sd">        reference to XML node in question, it is a good idea to run</span>
<span class="sd">        the method like this:</span>
<span class="sd">          &gt;&gt;&gt; node = root[&#39;a&#39;][&#39;b&#39;][0]</span>
<span class="sd">          &gt;&gt;&gt; node = node.strip_cdata(return_node=True)</span>
<span class="sd">        </span>
<span class="sd">        @type chars: text</span>
<span class="sd">        @param chars: A string containing the characters to</span>
<span class="sd">            strip. This is passed to the string class&#39; strip() method.</span>
<span class="sd">        @type return_node: bool</span>
<span class="sd">        @param return_node: Whether the method should return the</span>
<span class="sd">            updated node.</span>
<span class="sd">        @rtype: None or an appropriate node object.</span>
<span class="sd">        @return: If return_node is False, None; otherwise, the updated</span>
<span class="sd">            node object.</span>
<span class="sd">        @raises: AttributeError, if the node is out of date. (See</span>
<span class="sd">            L{get_current_node}.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
        <span class="n">newtext</span> <span class="o">=</span> <span class="n">_unicode</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cdata</span><span class="p">(),</span> <span class="n">chars</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_cdata</span><span class="p">(</span><span class="n">newtext</span><span class="p">,</span> <span class="n">return_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">_unicode</span><span class="p">(),</span> <span class="n">new_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">update</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an XML node to an XML tree.</span>
<span class="sd">        </span>
<span class="sd">        This method adds a new XML node as a child of the current</span>
<span class="sd">        node. If the current node is an XMLCDATANode, it will be</span>
<span class="sd">        converted to an XMLDictNode so that it can hold children. If</span>
<span class="sd">        the current node is an XMLDictNode and you attempt to add a</span>
<span class="sd">        node with a duplicate key, the code will create a list to hold</span>
<span class="sd">        the existing node and add the new node to the list.</span>
<span class="sd">        </span>
<span class="sd">        By default, all new nodes are created as L{XMLCDATANode}</span>
<span class="sd">        objects. You can include any keyword parameters that you could</span>
<span class="sd">        provide when creating an L{XMLCDATANode} object. If supplied,</span>
<span class="sd">        these additional keyword parameters are passed to the</span>
<span class="sd">        L{XMLCDATANode.__init__} function.</span>
<span class="sd">        </span>
<span class="sd">        @type tag: text</span>
<span class="sd">        @param tag: The XML tag of the node.</span>
<span class="sd">        @type key: text or tuple</span>
<span class="sd">        @param key: The dictionary key that the method should use for</span>
<span class="sd">            the node. If None (the default), the tag is used as the</span>
<span class="sd">            key.</span>
<span class="sd">        @type text: text</span>
<span class="sd">        @param text: The CDATA for the new node. (Default: an empty</span>
<span class="sd">            string)</span>
<span class="sd">        @type new_node: An instance of a subclass of L{XMLNodeBase}.</span>
<span class="sd">        @param new_node: If supplied, this will be used for the new</span>
<span class="sd">            node instead of a new instance of the XMLCDATANode. If</span>
<span class="sd">            supplied, the text parameter and additional keyword</span>
<span class="sd">            arguments are ignored.</span>
<span class="sd">        @type update: bool</span>
<span class="sd">        @param update: If True (the default), update the reverse</span>
<span class="sd">            linkages in the new node to point to the parent. If False,</span>
<span class="sd">            only create the one-way linkages from the parent to the</span>
<span class="sd">            child. (B{Note}: This should always be True unless you are</span>
<span class="sd">            creating a temporary tree for some reason. Setting this to</span>
<span class="sd">            False may create inconsistent data that causes problems later.)</span>

<span class="sd">        @raises: AttributeError, if the node is out of date and</span>
<span class="sd">            in_place is True. (See L{get_current_node}.)</span>
<span class="sd">        @raises: AttributeError, if in_place is True and the method</span>
<span class="sd">            encounters irrecoverable data inconsistency while making</span>
<span class="sd">            changes to the XML tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a node as a list.</span>
<span class="sd">        </span>
<span class="sd">        This method returns a node as a list. This is useful when you</span>
<span class="sd">        are not sure whether a node will contain a single entry or a</span>
<span class="sd">        list. If the node contains a list, the node itself is</span>
<span class="sd">        returned. If the node does not already contain a list, the</span>
<span class="sd">        method creates a list, adds the node to it, and returns the</span>
<span class="sd">        list.</span>
<span class="sd">        </span>
<span class="sd">        If the in_place parameter is True, then the change is made in</span>
<span class="sd">        the XML tree. Otherwise, the XML tree is left unchanged and</span>
<span class="sd">        the method creates and returns a temporary list.</span>
<span class="sd">        </span>
<span class="sd">        @type in_place: bool</span>
<span class="sd">        @param in_place: Whether the change should be made in the XML</span>
<span class="sd">            tree.</span>
<span class="sd">        @rtype: list or L{XMLListNode}</span>
<span class="sd">        @return: If the current node is a list, the current node;</span>
<span class="sd">            otherwise, a list containing the current node as its sole</span>
<span class="sd">            member.</span>
<span class="sd">        @raises: AttributeError, if the node is out of date and</span>
<span class="sd">            in_place is True. (See L{get_current_node}.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">XMLListNode</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
            <span class="n">convert</span><span class="o">=</span><span class="bp">False</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_node</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>

        <span class="c1"># We weren&#39;t &quot;replaced&quot; in the destructive sense, so clear</span>
        <span class="c1"># the replacement node indicator.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replacement_node</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># self._replace_node() may have updated our key if it was out</span>
        <span class="c1"># of date, so grab it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">new_node</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># Reparent ourselves.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">new_node</span>

        <span class="c1"># Return the list.</span>
        <span class="k">return</span> <span class="n">new_node</span>

    <span class="k">def</span> <span class="nf">get_current_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the current node.</span>
<span class="sd">        </span>
<span class="sd">        There are times that the current node must be replaced in the</span>
<span class="sd">        XML tree for some reason. For example, due to the immutability</span>
<span class="sd">        of Python strings, a new XMLCDATANode (which masquerades as a</span>
<span class="sd">        string) is required anytime its CDATA value changes.</span>
<span class="sd">        </span>
<span class="sd">        When this occurs, you can retrieve the latest node using the</span>
<span class="sd">        get_current_node() method. This will attempt to find the node</span>
<span class="sd">        that succeeded the node in question. If the node is still</span>
<span class="sd">        current, it simply returns itself.</span>
<span class="sd">        </span>
<span class="sd">        Therefore, it should always be safe to run:</span>
<span class="sd">          &gt;&gt;&gt; node = node.get_current_node()</span>
<span class="sd">        </span>
<span class="sd">        @rtype: A subclass of XMLNodeBase</span>
<span class="sd">        @return: The current successor to the node (if</span>
<span class="sd">            any). If the node is still &quot;current&quot;, the method returns the</span>
<span class="sd">            node itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replacement_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Recurse as deep as we can looking for replacement nodes.</span>
            <span class="c1"># If we hit an error, return the last replacement node we found.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replacement_node</span><span class="o">.</span><span class="n">_replacement_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_replacement_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replacement_node</span><span class="o">.</span><span class="n">_replacement_node</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replacement_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_replace_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newnode</span><span class="p">):</span>
        <span class="c1"># Replace a node with a new node. If the replacement node is</span>
        <span class="c1"># None, then the node is deleted.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
        <span class="c1"># We need to replace ourselves with a new node.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Attempt to modify root document&quot;</span><span class="p">)</span>
        <span class="c1"># Record the replacement for anyone who still holds</span>
        <span class="c1"># references to this node.</span>
        <span class="k">if</span> <span class="n">newnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_replacement_node</span> <span class="o">=</span> <span class="n">newnode</span>
        <span class="c1"># Case 1: Parent is dictionary</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Plan A: Do the lookup by expected key.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">newnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">newnode</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">return</span>
            <span class="c1"># Plan B: Brute force check, in case of some sort of</span>
            <span class="c1"># mismatch. We do our best, within reason.</span>
            <span class="n">myiter</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Python 2</span>
                <span class="n">myiter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># Python 3</span>
                <span class="n">myiter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">myiter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">newnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="c1"># Update the new node&#39;s key</span>
                        <span class="n">newnode</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                        <span class="c1"># Replace us</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">newnode</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">return</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">XMLListNode</span><span class="p">):</span>
                    <span class="c1"># Check the list</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">newnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="c1"># Update the new node&#39;s key and parent</span>
                                <span class="n">newnode</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                                <span class="n">newnode</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">val</span>
                                <span class="c1"># Replace us</span>
                                <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">newnode</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">del</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                <span class="c1"># Make sure we don&#39;t need to delete the</span>
                                <span class="c1"># enclosing list, too.</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">val</span><span class="o">.</span><span class="n">_replace_node</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                            <span class="k">return</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># Case 2: Parent is list</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">made_change</span><span class="o">=</span><span class="bp">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">newnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">newnode</span>
                        <span class="k">return</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">made_change</span><span class="o">=</span><span class="bp">True</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">made_change</span><span class="p">:</span>
                <span class="c1"># Make sure we don&#39;t need to delete the enclosing list,</span>
                <span class="c1"># too.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">_replace_node</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Unable to find existing node in parent&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">[],</span> <span class="n">tags</span><span class="o">=</span><span class="p">[],</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">promote</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary keyed as indicated by the parameters.</span>
<span class="sd">        </span>
<span class="sd">        This method lets you re-key your data with some</span>
<span class="sd">        flexibility. It takes the current node (whether a single node</span>
<span class="sd">        or a list) and turns it into a dictionary. If the current node</span>
<span class="sd">        is a list, all the list members are added to the</span>
<span class="sd">        dictionary. If the current node is not a list, just the</span>
<span class="sd">        current node is added to the dictonary.</span>
<span class="sd">        </span>
<span class="sd">        The key for each node is determined by the attrs, tags, and</span>
<span class="sd">        func parameters, in that order of precedence. For I{each</span>
<span class="sd">        node}, the method looks for child nodes that have an</span>
<span class="sd">        XML attribute that exactly matches one of the attributes in</span>
<span class="sd">        the attrs argument. If it finds a match, it uses the I{node&#39;s}</span>
<span class="sd">        (not the attribute&#39;s) CDATA as the key.</span>
<span class="sd">        </span>
<span class="sd">        If the method does not find a matching attribute, it looks for</span>
<span class="sd">        child nodes that have a tag that exactly matches one of the</span>
<span class="sd">        tags in the tags argument. If it finds a match, it uses the</span>
<span class="sd">        node&#39;s CDATA as the key.</span>
<span class="sd">        </span>
<span class="sd">        If the method does not find a matching tag, it passes the node</span>
<span class="sd">        to the user-suppled function (supplied by the func parameter)</span>
<span class="sd">        and uses the return value as the key.</span>
<span class="sd">        </span>
<span class="sd">        If the func is not provided or returns a value that evaluates to</span>
<span class="sd">        False (e.g. None or &quot;&quot;), the method uses the node&#39;s XML tag as</span>
<span class="sd">        the key.</span>
<span class="sd">        </span>
<span class="sd">        If there are multiple matches, the order of precedence is like</span>
<span class="sd">        this (again, this is applied for I{each node} independent of</span>
<span class="sd">        the other nodes):</span>
<span class="sd">          1. The attributes in the attrs parameter, in the order they</span>
<span class="sd">             appear in the attrs parameter.</span>
<span class="sd">          2. The tags in the tags parameter, in the order they appear</span>
<span class="sd">             in the attrs parameter.</span>
<span class="sd">          3. The return value of the user-supplied function.</span>
<span class="sd">          4. The node&#39;s XML tag.</span>
<span class="sd">        </span>
<span class="sd">        If the in_place parameter is True, then the method will</span>
<span class="sd">        replace the current node in the hierarchy with the</span>
<span class="sd">        dictionary. Otherwise, it will create a new dictionary and</span>
<span class="sd">        return it.</span>
<span class="sd">        </span>
<span class="sd">        If both the in_place and promote parameters are True, then the</span>
<span class="sd">        method will make the changes as described above; however, it</span>
<span class="sd">        will add the nodes to the first dictionary it finds enclosing</span>
<span class="sd">        the curent node.</span>
<span class="sd">        </span>
<span class="sd">        Some examples should help with this. Here is an example of the</span>
<span class="sd">        simple functionality. Note how the original nodes are turned</span>
<span class="sd">        into a dictionary with the appropriate keys, but the original</span>
<span class="sd">        root is left untouched:</span>
<span class="sd">          &gt;&gt;&gt; root.prettyprint()</span>
<span class="sd">          {&#39;a&#39;: {&#39;b&#39;: [{&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;},</span>
<span class="sd">                       {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;}]}}</span>
<span class="sd">          &gt;&gt;&gt; root[&#39;a&#39;][&#39;b&#39;].dict(tags=[&#39;name&#39;]).prettyprint()</span>
<span class="sd">          {u&#39;bar&#39;: {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;},</span>
<span class="sd">           u&#39;foo&#39;: {&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;}}</span>
<span class="sd">          &gt;&gt;&gt; root.prettyprint()</span>
<span class="sd">          {&#39;a&#39;: {&#39;b&#39;: [{&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;},</span>
<span class="sd">                       {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;}]}}</span>
<span class="sd">        </span>
<span class="sd">        Here is an example of a dictionary changed in place. Note how</span>
<span class="sd">        the original nodes are turned into a dictionary with the</span>
<span class="sd">        appropriate keys and this dictionary replaces the current node</span>
<span class="sd">        in the hierarchy:</span>
<span class="sd">          &gt;&gt;&gt; root.prettyprint()</span>
<span class="sd">          {&#39;a&#39;: {&#39;b&#39;: [{&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;},</span>
<span class="sd">                       {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;}]}}</span>
<span class="sd">          &gt;&gt;&gt; root[&#39;a&#39;][&#39;b&#39;].dict(tags=[&#39;name&#39;], in_place=True).prettyprint()</span>
<span class="sd">          {u&#39;bar&#39;: {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;},</span>
<span class="sd">           u&#39;foo&#39;: {&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;}}</span>
<span class="sd">          &gt;&gt;&gt; root.prettyprint()</span>
<span class="sd">          {&#39;a&#39;: {&#39;b&#39;: {u&#39;bar&#39;: {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;},</span>
<span class="sd">                       u&#39;foo&#39;: {&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;}}}}</span>
<span class="sd">        </span>
<span class="sd">        Here is an example of the &quot;promotion&quot; functionality. Note how</span>
<span class="sd">        the original nodes are added directly to the root[&#39;a&#39;]</span>
<span class="sd">        enclosing dictionary:</span>
<span class="sd">          &gt;&gt;&gt; root.prettyprint()</span>
<span class="sd">          {&#39;a&#39;: {&#39;b&#39;: [{&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;},</span>
<span class="sd">                       {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;}]}}</span>
<span class="sd">          &gt;&gt;&gt; root[&#39;a&#39;][&#39;b&#39;].dict(tags=[&#39;name&#39;], in_place=True, promote=True).prettyprint()</span>
<span class="sd">          {u&#39;bar&#39;: {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;},</span>
<span class="sd">           u&#39;foo&#39;: {&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;}}</span>
<span class="sd">          &gt;&gt;&gt; root.prettyprint()</span>
<span class="sd">          {&#39;a&#39;: {u&#39;bar&#39;: {&#39;name&#39;: u&#39;bar&#39;, &#39;value&#39;: u&#39;2&#39;},</span>
<span class="sd">                 u&#39;foo&#39;: {&#39;name&#39;: u&#39;foo&#39;, &#39;value&#39;: u&#39;1&#39;}}}</span>
<span class="sd">        </span>
<span class="sd">        Quirks:</span>
<span class="sd">          1. If the current node is the only member of a list in</span>
<span class="sd">             the XML tree, the operation will occur on that single-node</span>
<span class="sd">             list instead of the node itself.</span>
<span class="sd">          2. If the method encounters an exception while trying to</span>
<span class="sd">             modify the XML tree (in_place == True), it will attempt</span>
<span class="sd">             to undo its changes; however, this logic is not</span>
<span class="sd">             completely reliable.</span>

<span class="sd">        @type attrs: list</span>
<span class="sd">        @param attrs: The list of XML attributes that signal a node</span>
<span class="sd">            should be used as a key.</span>
<span class="sd">        @type tags: list</span>
<span class="sd">        @param attrs: The list of XML tags that signal a node</span>
<span class="sd">            should be used as a key.</span>
<span class="sd">        @type func: function</span>
<span class="sd">        @param func: A function that will accept a node as a parameter</span>
<span class="sd">            and return a key.</span>
<span class="sd">        @type in_place: bool</span>
<span class="sd">        @param in_place: Whether the change should be made in the XML</span>
<span class="sd">            tree.</span>
<span class="sd">        @type promote: bool</span>
<span class="sd">        @param promote: Whether the new nodes should be added to a</span>
<span class="sd">            dictonary placed at the current node, or they should be</span>
<span class="sd">            &quot;promoted&quot; to the first enclosing dictionary.</span>
<span class="sd">        @rtype: L{XMLDictNode}</span>
<span class="sd">        @return: If in_place is False, a dictionary formulated from</span>
<span class="sd">            the current node. If in_place is True, the dictionary to which</span>
<span class="sd">            the nodes were added. (Note: If promote is True, this</span>
<span class="sd">            dictionary may contain additional entries that already</span>
<span class="sd">            existed in the enclosing dictionary.)</span>
<span class="sd">        @raises: AttributeError, if the node is out of date and</span>
<span class="sd">            in_place is True. (See L{get_current_node}.)</span>
<span class="sd">        @raises: AttributeError, if in_place is True and the method</span>
<span class="sd">            encounters irrecoverable data inconsistency while making</span>
<span class="sd">            changes to the XML tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newlist</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="c1"># If editing in place, check that we are current.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>

            <span class="c1"># Save some information to help restore things, if needed.</span>
            <span class="n">orig</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>

            <span class="c1"># If we were editing in place, we need to figure out how to</span>
            <span class="c1"># properly replace ourselves.</span>
            <span class="c1">#</span>
            <span class="c1"># If our parent is a single-member list, then we can just</span>
            <span class="c1"># convert it. If our parent is a dictionary, then we can</span>
            <span class="c1"># convert ourselves in place. If our parent is anything</span>
            <span class="c1"># else, we just convert ourselves in place and do our best</span>
            <span class="c1"># to replace ourselves with a dictionary -- even if that</span>
            <span class="c1"># doesn&#39;t make complete sense.</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">XMLListNode</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="n">parent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="p">):</span>
                <span class="c1"># Easy. Just convert our parent.</span>
                <span class="n">newlist</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Turn us into a list.</span>
                <span class="n">newlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="n">in_place</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newlist</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Make a list and add us to it.</span>
            <span class="n">newlist</span> <span class="o">=</span> <span class="n">XMLListNode</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="bp">False</span>
            <span class="p">)</span>

        <span class="c1"># Now, let&#39;s turn the list node into a dict.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">newlist</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span>
                <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="n">tags</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="n">in_place</span><span class="p">,</span>
                <span class="n">promote</span><span class="o">=</span><span class="n">promote</span>
            <span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
                <span class="c1"># Try to restore us.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">orig</span><span class="p">[</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">orig</span><span class="p">[</span><span class="s1">&#39;tag&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">orig</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_replacement_node</span><span class="o">=</span><span class="bp">None</span>
                <span class="n">newlist</span><span class="o">.</span><span class="n">_replace_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">jdict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">promote</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary keyed appropriately for Junos output.</span>
<span class="sd">        </span>
<span class="sd">        This method is a shortcut to call the L{dict} method with these</span>
<span class="sd">        parameters:</span>
<span class="sd">          - attrs=[(&#39;junos:key&#39;, &#39;junos:key&#39;, &#39;junos:key&#39;),</span>
<span class="sd">                   (&#39;junos:key&#39;, &#39;junos:key&#39;), &#39;junos:key&#39;] </span>
<span class="sd">          - tags=[&#39;name&#39;]</span>
<span class="sd">        </span>
<span class="sd">        This will attempt to produce the correct key for each</span>
<span class="sd">        node. Some nodes have a multi-field key. If that occurs, the</span>
<span class="sd">        dictionary key will be a tuple. In cases where there is a</span>
<span class="sd">        single key, the dictionary key will be a string. If there is</span>
<span class="sd">        no matching node, the key will simply be the XML tag name.</span>
<span class="sd">        </span>
<span class="sd">        Some Junos nodes use a different tag for the key. And, in some</span>
<span class="sd">        cases, the junos:key attribute is not available. In those</span>
<span class="sd">        circumstances, you should directly call the L{dict} method</span>
<span class="sd">        with the correct attributes or tags.</span>
<span class="sd">        </span>
<span class="sd">        Please see the documentation for the L{dict} method for</span>
<span class="sd">        further information.</span>
<span class="sd">        </span>
<span class="sd">        @type in_place: bool</span>
<span class="sd">        @param in_place: Whether the change should be made in the XML</span>
<span class="sd">            tree.</span>
<span class="sd">        @type promote: bool</span>
<span class="sd">        @param promote: Whether the new nodes should be added to a</span>
<span class="sd">            dictonary placed at the current node, or they should be</span>
<span class="sd">            &quot;promoted&quot; to the first enclosing dictionary.</span>
<span class="sd">        @rtype: L{XMLDictNode}</span>
<span class="sd">        @return: If in_place is False, a dictionary formulated from</span>
<span class="sd">            the current node. If in_place is True, the dictionary to which</span>
<span class="sd">            the nodes were added. (Note: If promote is True, this</span>
<span class="sd">            dictionary may contain additional entries that already</span>
<span class="sd">            existed in the enclosing dictionary.)</span>
<span class="sd">        @raises: AttributeError, if the node is out of date and</span>
<span class="sd">            in_place is True. (See L{get_current_node}.)</span>
<span class="sd">        @raises: AttributeError, if in_place is True and the method</span>
<span class="sd">            encounters irrecoverable data inconsistency while making</span>
<span class="sd">            changes to the XML tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;junos:key&#39;</span><span class="p">,</span> <span class="s1">&#39;junos:key&#39;</span><span class="p">,</span> <span class="s1">&#39;junos:key&#39;</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;junos:key&#39;</span><span class="p">,</span> <span class="s1">&#39;junos:key&#39;</span><span class="p">),</span> <span class="s1">&#39;junos:key&#39;</span><span class="p">],</span>
                         <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">in_place</span><span class="o">=</span><span class="n">in_place</span><span class="p">,</span> <span class="n">promote</span><span class="o">=</span><span class="n">promote</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert all child nodes to instances of an L{XMLNodeBase} sub-class.</span>
<span class="sd">        </span>
<span class="sd">        This method is useful when you have added a child node</span>
<span class="sd">        directly to a dictionary or list and now want to convert it to</span>
<span class="sd">        the appropriate L{XMLNodeBase} sub-class.</span>
<span class="sd">        </span>
<span class="sd">        @type deep: bool</span>
<span class="sd">        @param deep: If True (the default), recursively descend</span>
<span class="sd">            through all children, converting all nodes, as needed. If</span>
<span class="sd">            False, only convert direct children of the node.</span>
<span class="sd">        @return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">emit_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content_handler</span><span class="p">,</span> <span class="n">pretty</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">newl</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                     <span class="n">indent</span><span class="o">=</span><span class="s1">&#39;    &#39;</span><span class="p">,</span> <span class="n">full_document</span><span class="o">=</span><span class="n">_NoArg</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;Pass the contents of the XML tree to a ContentHandler object.</span>
<span class="sd">        </span>
<span class="sd">        This method will pass the contents of the XML tree to a</span>
<span class="sd">        ContentHandler object.</span>
<span class="sd">        </span>
<span class="sd">        @type content_handler: A ContentHandler object</span>
<span class="sd">        @param content_handler: The ContentHandler object to which the</span>
<span class="sd">            XML tree wll be passed.</span>
<span class="sd">        @type pretty: bool</span>
<span class="sd">        @param pretty: If True, this method will call the</span>
<span class="sd">            content_handler.ignorableWhitespace() method to add</span>
<span class="sd">            whitespace to the output document.</span>
<span class="sd">        @type newl: text</span>
<span class="sd">        @param newl: The string which the method should use for new</span>
<span class="sd">            lines when adding white space (see the pretty parameter).</span>
<span class="sd">        @type indent: text</span>
<span class="sd">        @param indent: The string which the method should use for each</span>
<span class="sd">            level of indentation when adding white space (see the pretty</span>
<span class="sd">            parameter).</span>
<span class="sd">        @type full_document: bool</span>
<span class="sd">        @param full_document: If True, the method will call the</span>
<span class="sd">            content_handler.startDocument() and</span>
<span class="sd">            content_handler.endDocument() methods at the start and end of</span>
<span class="sd">            the document, respectively. If False, it will not call these</span>
<span class="sd">            methods. If the parameter is not set, the method will</span>
<span class="sd">            attempt to determine whether the current node is the root</span>
<span class="sd">            of an XML tree with a single root tag. If so, it will set</span>
<span class="sd">            the full_document parameter to True; otherwise, it will</span>
<span class="sd">            set it to False.</span>
<span class="sd">        @return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">full_document</span><span class="p">,</span> <span class="n">_NoArg</span><span class="p">):</span>
            <span class="c1"># Make sure there is only one root in a &quot;full&quot; document.</span>
            <span class="k">if</span> <span class="n">full_document</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">XMLListNode</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Document will have more than one root node. The full_document argument must be False.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">XMLListNode</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># We have multiple tags. We cannot be a full document.</span>
            <span class="n">full_document</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">XMLDictNode</span><span class="p">,</span> <span class="n">XMLListNode</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># We are the root. We have a single root tag.</span>
            <span class="n">full_document</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="p">(</span><span class="n">_unicode</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">tag</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="c1"># We look like the only child of the root node. In other words,</span>
            <span class="c1"># we look like the root tag. Treat us as a full document.</span>
            <span class="n">full_document</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We don&#39;t appear to be the root, or it appears there is a multi-</span>
            <span class="c1"># member root.</span>
            <span class="n">full_document</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">full_document</span><span class="p">:</span>
            <span class="n">content_handler</span><span class="o">.</span><span class="n">startDocument</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_emit_handler</span><span class="p">(</span><span class="n">content_handler</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pretty</span><span class="o">=</span><span class="n">pretty</span><span class="p">,</span> <span class="n">newl</span><span class="o">=</span><span class="n">newl</span><span class="p">,</span>
                           <span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">full_document</span><span class="p">:</span>
            <span class="n">content_handler</span><span class="o">.</span><span class="n">endDocument</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">emit_xml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">XMLGenerator</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the contents of the XML tree as an XML document.</span>
<span class="sd">        </span>
<span class="sd">        This method will create a ContentHandler by calling the</span>
<span class="sd">        method provided by the handler parameter.  It will call</span>
<span class="sd">        L{emit_handler} with this ContentHandler object.  In addition,</span>
<span class="sd">        this method will accept any parameter that the L{emit_handler}</span>
<span class="sd">        method accepts (except the content_handler parameter).  It will pass</span>
<span class="sd">        them to the L{emit_handler} method when it calls it.</span>
<span class="sd">        </span>
<span class="sd">        @type output: A file-like IO object, or None.</span>
<span class="sd">        @param output: The file-like IO object in which output should</span>
<span class="sd">            be placed. If None, the method will return the XML output</span>
<span class="sd">            as a string.</span>
<span class="sd">        @type encoding: text</span>
<span class="sd">        @param encoding: The encoding that should be used for the output.</span>
<span class="sd">        @type handler: function</span>
<span class="sd">        @param handler: A method that will return a ContentHandler</span>
<span class="sd">            object. This method will be called with two positional</span>
<span class="sd">            parameters: the output parameter (or, if None, a file-like IO</span>
<span class="sd">            object) and the encoding parameter.</span>
<span class="sd">        @return: If output was None, the method will return the XML</span>
<span class="sd">            output as a string. Otherwise, None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
            <span class="n">return_text</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_text</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">content_handler</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">encoding</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">emit_handler</span><span class="p">(</span><span class="n">content_handler</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_text</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># pragma no cover</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># pragma no cover</span>
                <span class="k">pass</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">prettyprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print a &quot;pretty&quot; representation of the data structure.</span>
<span class="sd">        </span>
<span class="sd">        This uses the Python pprint method to print a &quot;pretty&quot;</span>
<span class="sd">        representation of the data structure. The parameters are</span>
<span class="sd">        passed unchanged to the Python pprint method.</span>
<span class="sd">        </span>
<span class="sd">        This shows only the main data and not the meta data (such as</span>
<span class="sd">        XML attributes).</span>
<span class="sd">        </span>
<span class="sd">        When using pprint, it is necessary to use this method to get a</span>
<span class="sd">        reasonable representation of the data; otherwise, pprint will</span>
<span class="sd">        not know how to represent the object in a &quot;pretty&quot; way.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">find_nodes_with_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterates over nodes that have a matching tag.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: This documentation needs to be updated to take into</span>
<span class="sd">        account the changes to list handling and always checking the</span>
<span class="sd">        current node&#39;s tag.</span>
<span class="sd">        </span>
<span class="sd">        This method searches for a node that is a descendant of the</span>
<span class="sd">        current node and has a matching tag. Optionally (by providing</span>
<span class="sd">        a False argument to the recursive parameter), you can limit</span>
<span class="sd">        the search to direct children of the current node. In either</span>
<span class="sd">        case, the tag of the current node is not checked.</span>
<span class="sd">        </span>
<span class="sd">        For example, this will print all &quot;name&quot; nodes from the XML</span>
<span class="sd">        snippet that is shown:</span>
<span class="sd">          &gt;&gt;&gt; root = jxmlease.parse(\&quot;\&quot;\&quot;\</span>
<span class="sd">          ... &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="sd">          ... &lt;name&gt;</span>
<span class="sd">          ...     &lt;a&gt;</span>
<span class="sd">          ...         &lt;name&gt;name #1&lt;/name&gt;</span>
<span class="sd">          ...         &lt;b&gt;</span>
<span class="sd">          ...             &lt;name&gt;name #2&lt;/name&gt;</span>
<span class="sd">          ...         &lt;/b&gt;</span>
<span class="sd">          ...         &lt;b&gt;</span>
<span class="sd">          ...             &lt;c&gt;</span>
<span class="sd">          ...                 &lt;name&gt;name #3&lt;/name&gt;</span>
<span class="sd">          ...             &lt;/c&gt;</span>
<span class="sd">          ...         &lt;/b&gt;</span>
<span class="sd">          ...     &lt;/a&gt;</span>
<span class="sd">          ... &lt;/name&gt;\&quot;\&quot;\&quot;)</span>
<span class="sd">          &gt;&gt;&gt; print root</span>
<span class="sd">          {u&#39;name&#39;: {u&#39;a&#39;: {u&#39;b&#39;: [{u&#39;name&#39;: u&#39;name #2&#39;},</span>
<span class="sd">                                   {u&#39;c&#39;: {u&#39;name&#39;: u&#39;name #3&#39;}}],</span>
<span class="sd">                            u&#39;name&#39;: u&#39;name #1&#39;}}}</span>
<span class="sd">          &gt;&gt;&gt; for node in root.find_nodes_with_tag(&#39;name&#39;):</span>
<span class="sd">          ...   print node</span>
<span class="sd">          ... </span>
<span class="sd">          name #1</span>
<span class="sd">          name #2</span>
<span class="sd">          name #3</span>
<span class="sd">        </span>
<span class="sd">        However, if we turn off recursion, you will see that this</span>
<span class="sd">        returns only the direct children (if any) of the node we</span>
<span class="sd">        select:</span>
<span class="sd">          &gt;&gt;&gt; for node in root.find_nodes_with_tag(&#39;name&#39;, recursive=False):</span>
<span class="sd">          ...   print node</span>
<span class="sd">          ... </span>
<span class="sd">          &gt;&gt;&gt; for node in root[&#39;name&#39;][&#39;a&#39;].find_nodes_with_tag(&#39;name&#39;, recursive=False):</span>
<span class="sd">          ...   print node</span>
<span class="sd">          ... </span>
<span class="sd">          name #1</span>

<span class="sd">        If you run this against an XMLDictNode without a tag (for</span>
<span class="sd">        example, the tagless root node), then the command is run on</span>
<span class="sd">        each member of the dictionary. The impact of this is that it</span>
<span class="sd">        will search for tags in the grandchildren of the tagless</span>
<span class="sd">        XMLDictNode, rather than searching the children of the tagless</span>
<span class="sd">        XMLDictNode:</span>
<span class="sd">          &gt;&gt;&gt; root = jxmlease.parse(&quot;&lt;name&gt;top-level tag&lt;/name&gt;&quot;)</span>
<span class="sd">          &gt;&gt;&gt; for i in root.find_nodes_with_tag(&#39;name&#39;):</span>
<span class="sd">          ...   print i</span>
<span class="sd">          ... </span>
<span class="sd">          &gt;&gt;&gt; root = jxmlease.parse(\&quot;\&quot;\&quot;\</span>
<span class="sd">          ... &lt;a&gt;</span>
<span class="sd">          ...   &lt;name&gt;second-level tag&lt;/name&gt;</span>
<span class="sd">          ... &lt;/a&gt;\&quot;\&quot;\&quot;)</span>
<span class="sd">          &gt;&gt;&gt; for i in root.find_nodes_with_tag(&#39;name&#39;):</span>
<span class="sd">          ...   print i</span>
<span class="sd">          ... </span>
<span class="sd">          second-level tag</span>
<span class="sd">        </span>
<span class="sd">        If the current node is a list and it appears that the list was</span>
<span class="sd">        created to hold multiple elements with the same tag, then the</span>
<span class="sd">        command is run on each member of the list (rather than on the</span>
<span class="sd">        list itself). The impact of this is that it will search for</span>
<span class="sd">        tags in the grandchildren of the XMLListNode, rather</span>
<span class="sd">        than searching the children of the XMLListNode.</span>
<span class="sd">        </span>
<span class="sd">        As confusing as this may sound, the point is simple: we never</span>
<span class="sd">        check the tag of the &quot;current&quot; element. Because lists can be</span>
<span class="sd">        homogenous or heterogenous, that statement is ambiguous for</span>
<span class="sd">        lists. We resolve the ambiguity by comparing the tag stored</span>
<span class="sd">        with the list and the tag of the children. :</span>
<span class="sd">        </span>
<span class="sd">        For example, here is a root node with two top-level &quot;name&quot;</span>
<span class="sd">        elements. Searching for the &quot;name&quot; tag does not find these</span>
<span class="sd">        top-level elements because both the top-level dictionary and</span>
<span class="sd">        top-level list pass through the search:</span>
<span class="sd">          &gt;&gt;&gt; root = XMLDictNode()</span>
<span class="sd">          &gt;&gt;&gt; _ = root.add_node(tag=&#39;name&#39;, text=&#39;tag #1&#39;)</span>
<span class="sd">          &gt;&gt;&gt; _ = root.add_node(tag=&#39;name&#39;, text=&#39;tag #2&#39;)</span>
<span class="sd">          &gt;&gt;&gt; print root</span>
<span class="sd">          {&#39;name&#39;: [u&#39;tag #1&#39;, u&#39;tag #2&#39;]}</span>
<span class="sd">          &gt;&gt;&gt; for i in root.find_nodes_with_tag(&#39;name&#39;):</span>
<span class="sd">          ...   print i</span>
<span class="sd">          ... </span>
<span class="sd">          &gt;&gt;&gt;</span>
<span class="sd">        </span>
<span class="sd">        On the other hand, we create a root XMLListNode and add two</span>
<span class="sd">        name tags to it. Because the XMLListNode has no internal</span>
<span class="sd">        representation of its tag, it checks for matches in its</span>
<span class="sd">        children. Note that you shouldn&#39;t really create XML trees this</span>
<span class="sd">        way; rather, you should always have an XMLDictNode as the</span>
<span class="sd">        root. However, this shows the concept:</span>
<span class="sd">          &gt;&gt;&gt; badroot = XMLListNode()</span>
<span class="sd">          &gt;&gt;&gt; badroot.append(XMLCDATANode(&#39;tag #1&#39;, tag=&#39;name&#39;))</span>
<span class="sd">          &gt;&gt;&gt; badroot.append(XMLCDATANode(&#39;tag #2&#39;, tag=&#39;name&#39;))</span>
<span class="sd">          &gt;&gt;&gt; print badroot</span>
<span class="sd">          [u&#39;tag #1&#39;, u&#39;tag #2&#39;]</span>
<span class="sd">          &gt;&gt;&gt; print root.emit_xml()</span>
<span class="sd">          &lt;name&gt;tag #1&lt;/name&gt;</span>
<span class="sd">          &lt;name&gt;tag #2&lt;/name&gt;</span>
<span class="sd">          &gt;&gt;&gt; for i in badroot.find_nodes_with_tag(&#39;name&#39;):</span>
<span class="sd">          ...   print i</span>
<span class="sd">          ... </span>
<span class="sd">          tag #1</span>
<span class="sd">          tag #2</span>

<span class="sd">        Also, note that this method returns the actual node:</span>
<span class="sd">          &gt;&gt;&gt; root = jxmlease.parse(\&quot;\&quot;\&quot;\</span>
<span class="sd">          ... &lt;a&gt;</span>
<span class="sd">          ...   &lt;b&gt;</span>
<span class="sd">          ...     &lt;c&gt;</span>
<span class="sd">          ...       &lt;foo&gt;bar&lt;/foo&gt;</span>
<span class="sd">          ...       &lt;status&gt;ok&lt;/status&gt;</span>
<span class="sd">          ...     &lt;/c&gt;</span>
<span class="sd">          ...   &lt;/b&gt;</span>
<span class="sd">          ... &lt;/a&gt;\&quot;\&quot;\&quot;)</span>
<span class="sd">          &gt;&gt;&gt; for i in root.find_nodes_with_tag(&#39;b&#39;):</span>
<span class="sd">          ...   print i</span>
<span class="sd">          ... </span>
<span class="sd">          {u&#39;c&#39;: {u&#39;foo&#39;: u&#39;bar&#39;, u&#39;status&#39;: u&#39;ok&#39;}}</span>
<span class="sd">        </span>
<span class="sd">        You can also use a tuple as the tag parameter, in which case</span>
<span class="sd">        the method will return nodes with a tag that matches any of</span>
<span class="sd">        the given tag values.</span>
<span class="sd">        </span>
<span class="sd">        You can use this function to create somewhat complicated logic</span>
<span class="sd">        that mimics the functionality from XPath &quot;//tag&quot; matches. For</span>
<span class="sd">        example, here we check for &lt;xnm:warning&gt; and &lt;xnm:error&gt; nodes</span>
<span class="sd">        and return their value:</span>
<span class="sd">          &gt;&gt;&gt; root = jxmlease.parse(\&quot;\&quot;\&quot;\</span>
<span class="sd">          ... &lt;foo&gt;</span>
<span class="sd">          ...   &lt;xnm:warning&gt;</span>
<span class="sd">          ...     &lt;message&gt;This is bad.&lt;/message&gt;</span>
<span class="sd">          ...   &lt;/xnm:warning&gt;</span>
<span class="sd">          ...   &lt;bar&gt;</span>
<span class="sd">          ...     &lt;xnm:error&gt;</span>
<span class="sd">          ...       &lt;message&gt;This is very bad.&lt;/message&gt;</span>
<span class="sd">          ...     &lt;/xnm:error&gt;</span>
<span class="sd">          ...   &lt;/bar&gt;</span>
<span class="sd">          ... &lt;/foot&gt;\&quot;\&quot;\&quot;)</span>
<span class="sd">          &gt;&gt;&gt; if root.has_node_with_tag((&#39;xnm:warning&#39;, &#39;xnm:error&#39;)):</span>
<span class="sd">          ...   print &quot;Something bad happened.&quot;</span>
<span class="sd">          ... </span>
<span class="sd">          Something bad happened.</span>
<span class="sd">          &gt;&gt;&gt; for node in root.find_nodes_with_tag((&#39;xnm:warning&#39;, &#39;xnm:error&#39;)):</span>
<span class="sd">          ...   if node.tag == &#39;xnm:error&#39;:</span>
<span class="sd">          ...     level = &quot;Error:&quot;</span>
<span class="sd">          ...   elif node.tag == &#39;xnm:warning&#39;:</span>
<span class="sd">          ...     level = &quot;Warning:&quot;</span>
<span class="sd">          ...   else:</span>
<span class="sd">          ...     level = &quot;Unknown:&quot;</span>
<span class="sd">          ...   print(level + &quot; &quot; + node.get(&quot;message&quot;, &quot;(unknown)&quot;))</span>
<span class="sd">          ... </span>
<span class="sd">          Warning: This is bad.</span>
<span class="sd">          Error: This is very bad.</span>
<span class="sd">        </span>
<span class="sd">        Once a given node matches, the method does not check that</span>
<span class="sd">        node&#39;s children.</span>
<span class="sd">        </span>
<span class="sd">        @type tag: text or tuple</span>
<span class="sd">        @param tag: The XML tag (or tags) for which to search.</span>
<span class="sd">        @type recursive: bool</span>
<span class="sd">        @param key: If True (the default), search recursively through</span>
<span class="sd">            all children. If False, only search direct children.</span>
<span class="sd">        @return: A generator which iterates over all matching nodes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">tag</span><span class="p">,)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_nodes_with_tag</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tag</span><span class="p">),</span> <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">,</span>
                                         <span class="n">top_level</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_nodes_with_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">recursive</span><span class="p">,</span> <span class="n">top_level</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">has_node_with_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine whether a node with a matching tag exists.</span>
<span class="sd">        </span>
<span class="sd">        This method uses the L{find_nodes_with_tag} method to search</span>
<span class="sd">        for a node that is a child of the current node and has a</span>
<span class="sd">        matching tag. The tag of the current node is not checked. The</span>
<span class="sd">        method returns a boolean value to indicate whether at least</span>
<span class="sd">        one matching node is found.</span>
<span class="sd">        </span>
<span class="sd">        Because this function uses the L{find_nodes_with_tag} method,</span>
<span class="sd">        the parameters and algorithm are the same as the</span>
<span class="sd">        L{find_nodes_with_tag} method.</span>
<span class="sd">        </span>
<span class="sd">        @type tag: text or tuple</span>
<span class="sd">        @param tag: The XML tag (or tags) for which to search.</span>
<span class="sd">        @type recursive: bool</span>
<span class="sd">        @param key: If True (the default), search recursively through</span>
<span class="sd">            all children. If False, only search direct children.</span>
<span class="sd">        @return: True if at least one matching node is found;</span>
<span class="sd">            otherwise, False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nodes_with_tag</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(xml_attrs=</span><span class="si">%r</span><span class="s2">, value=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;__const_class_name__&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xml_attrs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parent_class__</span><span class="o">.</span><span class="n">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">io_obj</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">(</span><span class="n">io_obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">io_obj</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">XMLCDATANode</span><span class="p">(</span><span class="n">XMLNodeBase</span><span class="p">,</span> <span class="n">_unicode</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_unicode</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
        <span class="c1"># Hmmm... We were a CDATA node, but we need to become a</span>
        <span class="c1"># dictionary so we can have members.</span>
        <span class="n">newnode</span> <span class="o">=</span> <span class="n">XMLDictNode</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                              <span class="n">text</span><span class="o">=</span><span class="n">_unicode</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">xml_attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xml_attrs</span><span class="p">)</span>
        <span class="c1"># Now, add the new node as a child of our replacement.</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">newnode</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Finally, replace ourselves.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_node</span><span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rv</span>

    <span class="k">def</span> <span class="nf">set_cdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">return_node</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
        <span class="n">newnode</span> <span class="o">=</span> <span class="n">XMLCDATANode</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span>
                               <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">xml_attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xml_attrs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_node</span><span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_node</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">newnode</span>

    <span class="k">def</span> <span class="nf">append_cdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">return_node</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_cdata</span><span class="p">(</span><span class="n">_unicode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">return_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_cdata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_unicode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="c1"># There is nothing to do.</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_emit_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content_handler</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">pretty</span><span class="p">,</span> <span class="n">newl</span><span class="p">,</span> <span class="n">indent</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pretty</span><span class="p">:</span>
            <span class="n">content_handler</span><span class="o">.</span><span class="n">ignorableWhitespace</span><span class="p">(</span><span class="n">depth</span> <span class="o">*</span> <span class="n">indent</span><span class="p">)</span>
        <span class="n">content_handler</span><span class="o">.</span><span class="n">startElement</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">AttributesImpl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xml_attrs</span><span class="p">))</span>
        <span class="n">content_handler</span><span class="o">.</span><span class="n">characters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cdata</span><span class="p">())</span>
        <span class="n">content_handler</span><span class="o">.</span><span class="n">endElement</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pretty</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">content_handler</span><span class="o">.</span><span class="n">ignorableWhitespace</span><span class="p">(</span><span class="n">newl</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prettyprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">currdepth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;currdepth&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">newobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parent_class__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">currdepth</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">pprint</span><span class="p">(</span><span class="n">newobj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">newobj</span>

    <span class="k">def</span> <span class="nf">_find_nodes_with_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">top_level</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span> <span class="ow">in</span> <span class="n">tag</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span>

<span class="k">def</span> <span class="nf">_get_dict_value_iter</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">descr</span><span class="o">=</span><span class="s2">&quot;node&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">XMLDictNode</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Python 2</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># Python 3</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">XMLCDATANode</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">arg</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unexpected type </span><span class="si">%s</span><span class="s2"> for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)),</span> <span class="n">descr</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">XMLListNode</span><span class="p">(</span><span class="n">XMLNodeBase</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an XML node to the XML tree.</span>
<span class="sd">        </span>
<span class="sd">        You should not call this method on an XMLListNode. Instead,</span>
<span class="sd">        call the add_node method on an L{XMLCDATANode} or an</span>
<span class="sd">        L{XMLDictNode}.</span>
<span class="sd">        </span>
<span class="sd">        @raises: AttributeError, if the node is out of date. (See</span>
<span class="sd">            L{get_current_node}.)</span>
<span class="sd">        @raises: TypeError, if called on an XMLListNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unable to add a child node to a list. Either add the node to the list&#39;s parent or one of the list members.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">[],</span> <span class="n">tags</span><span class="o">=</span><span class="p">[],</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">promote</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">class</span> <span class="nc">KeyBuilder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matches</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">key_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tuple</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">key_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">matches</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tuple</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">))]</span>

            <span class="k">def</span> <span class="nf">eval_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_list</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
                <span class="n">found_match</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key_list</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">value_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
                            <span class="n">found_match</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="n">found_match</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="bp">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_list</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tuple</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value_list</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">newnode</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">promote</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">XMLDictNode</span><span class="p">):</span>
                    <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">parent</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">parent</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;promote argument is True, but no parent was a dictionary&quot;</span>
                    <span class="p">)</span>
                <span class="n">newnode</span> <span class="o">=</span> <span class="n">parent</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_replace_node</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newnode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">newnode</span> <span class="o">=</span> <span class="n">XMLDictNode</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
            <span class="n">newnode</span><span class="o">.</span><span class="n">_ignore_level</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">newkey</span><span class="o">=</span><span class="bp">None</span>
                <span class="k">for</span> <span class="n">attr_keys</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                    <span class="n">key_check</span> <span class="o">=</span> <span class="n">KeyBuilder</span><span class="p">(</span><span class="n">attr_keys</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">grandchild</span> <span class="ow">in</span> <span class="n">_get_dict_value_iter</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;child node attributes&quot;</span><span class="p">):</span>
                        <span class="c1"># The grandchild might be a list.</span>
                        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">grandchild</span><span class="o">.</span><span class="n">list</span><span class="p">():</span>
                            <span class="n">newkey</span> <span class="o">=</span> <span class="n">key_check</span><span class="o">.</span><span class="n">eval_key</span><span class="p">(</span>
                                <span class="nb">list</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">xml_attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                                <span class="n">item</span><span class="o">.</span><span class="n">get_cdata</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                            <span class="p">)</span>
                            <span class="k">if</span> <span class="n">newkey</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="k">break</span>
                        <span class="k">if</span> <span class="n">newkey</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="n">newkey</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">newkey</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">tag_keys</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">:</span>
                        <span class="n">key_check</span> <span class="o">=</span> <span class="n">KeyBuilder</span><span class="p">(</span><span class="n">tag_keys</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">grandchild</span> <span class="ow">in</span> <span class="n">_get_dict_value_iter</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;child node&quot;</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">grandchild</span><span class="o">.</span><span class="n">list</span><span class="p">():</span>
                                <span class="n">newkey</span> <span class="o">=</span> <span class="n">key_check</span><span class="o">.</span><span class="n">eval_key</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">tag</span><span class="p">],</span>
                                    <span class="n">item</span><span class="o">.</span><span class="n">get_cdata</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                                <span class="p">)</span>
                                <span class="k">if</span> <span class="n">newkey</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                                    <span class="k">break</span>
                            <span class="k">if</span> <span class="n">newkey</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="k">break</span>
                        <span class="k">if</span> <span class="n">newkey</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="n">newkey</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">func</span><span class="p">:</span>
                        <span class="n">newkey</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">newkey</span><span class="p">:</span>
                    <span class="n">newkey</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span>
                <span class="n">newnode</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">newkey</span><span class="p">,</span> <span class="n">new_node</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>
                                 <span class="n">update</span><span class="o">=</span><span class="n">in_place</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># Do our best to restore things if something goes wrong</span>
            <span class="c1"># after we&#39;ve already made changes. (Actually, even this</span>
            <span class="c1"># is bogus. If we&#39;ve already re-added some of the nodes,</span>
            <span class="c1"># they will end up in both places.)</span>
            <span class="k">if</span> <span class="n">in_place</span> <span class="ow">and</span> <span class="n">promote</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">XMLListNode</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">new_node</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">if</span> <span class="n">in_place</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">promote</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_replace_node</span><span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newnode</span>

    <span class="k">def</span> <span class="nf">standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">XMLNodeBase</span><span class="p">):</span>
                <span class="c1"># Guess at the tag/key based on our own values. Set</span>
                <span class="c1"># the parent value correctly.</span>
                <span class="c1"># If we were told to do a deep conversion, then convert</span>
                <span class="c1"># the child; otherwise, don&#39;t.</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">convert</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span>
                              <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

                <span class="c1"># Convert dicts to XMLDictNodes.</span>
                <span class="c1"># Convert lists to XMLListNodes.</span>
                <span class="c1"># Convert everything else to an XMLCDATANode with</span>
                <span class="c1"># a best guess for the correct string value.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">OrderedDict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">XMLDictNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">XMLListNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">node</span> <span class="o">=</span> <span class="n">_unicode</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">_unicode</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                        <span class="n">node</span> <span class="o">=</span> <span class="n">_unicode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">XMLCDATANode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Update the internal book-keeping entries that might</span>
                <span class="c1"># need to be changed.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">):</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span>
                <span class="n">node</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span>
                <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_emit_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content_handler</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">pretty</span><span class="p">,</span> <span class="n">newl</span><span class="p">,</span> <span class="n">indent</span><span class="p">):</span>
        <span class="n">first_element</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pretty</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">first_element</span><span class="p">:</span>
                <span class="n">content_handler</span><span class="o">.</span><span class="n">ignorableWhitespace</span><span class="p">(</span><span class="n">newl</span><span class="p">)</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_emit_handler</span><span class="p">(</span><span class="n">content_handler</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">pretty</span><span class="p">,</span> <span class="n">newl</span><span class="p">,</span> <span class="n">indent</span><span class="p">)</span>
            <span class="n">first_element</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">prettyprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">currdepth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;currdepth&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="n">currdepth</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="c1"># Construct a new item, recursively.</span>
        <span class="n">newlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;prettyprint&quot;</span><span class="p">):</span>
                <span class="n">newlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">currdepth</span><span class="o">=</span><span class="n">currdepth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                             <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">currdepth</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">pprint</span><span class="p">(</span><span class="n">newlist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">newlist</span>

    <span class="k">def</span> <span class="nf">_find_nodes_with_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">top_level</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="c1"># Never return a list; only its descendants. When code calls</span>
        <span class="c1"># this method on a list, always call it for all the list</span>
        <span class="c1"># children.</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;recursive&#39;</span><span class="p">:</span> <span class="n">recursive</span><span class="p">}</span>

            <span class="c1"># If the list child has the same tag as the list, then</span>
            <span class="c1"># assume that the list is an automatic list to group</span>
            <span class="c1"># multiple items with the same tag. Therefore, run</span>
            <span class="c1"># this function on the list child as if it were being</span>
            <span class="c1"># run on the list itself.</span>
            <span class="c1">#</span>
            <span class="c1"># In this case, that means to pass on the top_level</span>
            <span class="c1"># marker unchanged.</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;top_level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_level</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">_find_nodes_with_tag</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">item</span>

<div class="viewcode-block" id="XMLDictNode"><a class="viewcode-back" href="../objects.html#jxmlease.XMLDictNode">[docs]</a><span class="k">class</span> <span class="nc">XMLDictNode</span><span class="p">(</span><span class="n">XMLNodeBase</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__const_class_name__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignore_level</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">OrderedDict</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="XMLDictNode.add_node"><a class="viewcode-back" href="../objects.html#jxmlease.XMLDictNode.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">_unicode</span><span class="p">(),</span> <span class="n">new_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">update</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">new_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># By default, we create a CDATA node.</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">XMLCDATANode</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                    <span class="n">new_node</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">tag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">XMLNodeBase</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;new_node&#39; argument must be a subclass of XMLNodeBase, not &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                    <span class="n">new_node</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">new_node</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">.</span><span class="n">key</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">tag</span>
            <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span>

        <span class="c1"># Let&#39;s see if we already have an entry with this key. If so,</span>
        <span class="c1"># it needs to be a list.</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># Make it a list, if not already.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">XMLListNode</span><span class="p">):</span>
                <span class="n">old_node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">XMLListNode</span><span class="p">([</span><span class="n">old_node</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                                        <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                    <span class="n">old_node</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">old_node</span>

            <span class="c1"># Add the new node to the list.</span>
            <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Add to the dictionary.</span>
            <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span>
        <span class="k">return</span> <span class="n">new_node</span></div>

<div class="viewcode-block" id="XMLDictNode.standardize"><a class="viewcode-back" href="../objects.html#jxmlease.XMLDictNode.standardize">[docs]</a>    <span class="k">def</span> <span class="nf">standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">XMLNodeBase</span><span class="p">):</span>
                <span class="c1"># Set the key and parent. Assume the tag is the same</span>
                <span class="c1"># as the key.</span>
                <span class="c1"># If we were told to do a deep conversion, then convert</span>
                <span class="c1"># the child; otherwise, don&#39;t.</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">convert</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                              <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

                <span class="c1"># Convert dicts to XMLDictNodes.</span>
                <span class="c1"># Convert lists to XMLListNodes.</span>
                <span class="c1"># Convert everything else to an XMLCDATANode with</span>
                <span class="c1"># a best guess for the correct string value.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">OrderedDict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">XMLDictNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">XMLListNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">node</span> <span class="o">=</span> <span class="n">_unicode</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">_unicode</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                        <span class="n">node</span> <span class="o">=</span> <span class="n">_unicode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">XMLCDATANode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Update the internal book-keeping entries that might</span>
                <span class="c1"># need to be changed.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_replacement</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">node</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_emit_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content_handler</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">pretty</span><span class="p">,</span> <span class="n">newl</span><span class="p">,</span> <span class="n">indent</span><span class="p">):</span>
        <span class="c1"># Special case: If tag is None and depth is 0, then we might be the</span>
        <span class="c1"># root container, which is tagless.</span>
        <span class="c1"># Special case: If self._ignore_level is True, then we just want to</span>
        <span class="c1"># work on the children.</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ignore_level</span><span class="p">:</span>
            <span class="n">first_element</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pretty</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">first_element</span><span class="p">:</span>
                    <span class="n">content_handler</span><span class="o">.</span><span class="n">ignorableWhitespace</span><span class="p">(</span><span class="n">newl</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">_emit_handler</span><span class="p">(</span><span class="n">content_handler</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">pretty</span><span class="p">,</span> <span class="n">newl</span><span class="p">,</span> <span class="n">indent</span><span class="p">)</span>
                <span class="n">first_element</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">pretty</span><span class="p">:</span>
            <span class="n">content_handler</span><span class="o">.</span><span class="n">ignorableWhitespace</span><span class="p">(</span><span class="n">depth</span> <span class="o">*</span> <span class="n">indent</span><span class="p">)</span>
        <span class="n">content_handler</span><span class="o">.</span><span class="n">startElement</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">AttributesImpl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xml_attrs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">pretty</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">content_handler</span><span class="o">.</span><span class="n">ignorableWhitespace</span><span class="p">(</span><span class="n">newl</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">_emit_handler</span><span class="p">(</span><span class="n">content_handler</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">pretty</span><span class="p">,</span> <span class="n">newl</span><span class="p">,</span> <span class="n">indent</span><span class="p">)</span>
        <span class="n">content_handler</span><span class="o">.</span><span class="n">characters</span><span class="p">(</span><span class="n">_unicode</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cdata</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">pretty</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">content_handler</span><span class="o">.</span><span class="n">ignorableWhitespace</span><span class="p">(</span><span class="n">depth</span> <span class="o">*</span> <span class="n">indent</span><span class="p">)</span>
        <span class="n">content_handler</span><span class="o">.</span><span class="n">endElement</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pretty</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">content_handler</span><span class="o">.</span><span class="n">ignorableWhitespace</span><span class="p">(</span><span class="n">newl</span><span class="p">)</span>

<div class="viewcode-block" id="XMLDictNode.prettyprint"><a class="viewcode-back" href="../objects.html#jxmlease.XMLDictNode.prettyprint">[docs]</a>    <span class="k">def</span> <span class="nf">prettyprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">currdepth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;currdepth&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="n">currdepth</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="c1"># Construct a new item, recursively.</span>
        <span class="n">newdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;prettyprint&quot;</span><span class="p">):</span>
                <span class="n">newdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">prettyprint</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">currdepth</span><span class="o">=</span><span class="n">currdepth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">if</span> <span class="n">currdepth</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">pprint</span><span class="p">(</span><span class="n">newdict</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">newdict</span></div>

    <span class="k">def</span> <span class="nf">_find_nodes_with_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">top_level</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="c1"># Special case: If tag is None and top_level is True, then</span>
        <span class="c1"># we might be the root container, which is tagless.</span>
        <span class="c1"># Special case: If self._ignore_level is True, then we just</span>
        <span class="c1"># want to work on the children.</span>
        <span class="n">pass_through</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ignore_level</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">top_level</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span> <span class="ow">in</span> <span class="n">tag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pass_through</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">recursive</span> <span class="ow">or</span> <span class="n">top_level</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;recursive&#39;</span><span class="p">:</span> <span class="n">recursive</span><span class="p">}</span>
                <span class="c1"># Pass through the top_level arg, if appropriate.</span>
                <span class="k">if</span> <span class="n">pass_through</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;top_level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_level</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">_find_nodes_with_tag</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">item</span></div>

<span class="k">class</span> <span class="nc">_GeneratorMatch</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># Essentially, a data structure used to hold information on matches.</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rooted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[],</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">match_string</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rooted</span> <span class="o">=</span> <span class="n">rooted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_string</span> <span class="o">=</span> <span class="n">match_string</span>

<span class="k">class</span> <span class="nc">_DictSAXHandler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># A handler for SAX events.</span>
    <span class="c1"># parameters are documented under the Parser class.</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">xml_attribs</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">strip_whitespace</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">namespace_separator</span><span class="o">=</span><span class="n">_unicode</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">),</span>
                 <span class="n">namespaces</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">strip_namespace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">cdata_separator</span><span class="o">=</span><span class="n">_unicode</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">),</span>
                 <span class="n">generator</span><span class="o">=</span><span class="p">[]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">XMLDictNode</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">item_depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xml_attribs</span> <span class="o">=</span> <span class="n">xml_attribs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strip_whitespace</span> <span class="o">=</span> <span class="n">strip_whitespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace_separator</span> <span class="o">=</span> <span class="n">namespace_separator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespaces</span> <span class="o">=</span> <span class="n">namespaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strip_namespace</span> <span class="o">=</span> <span class="n">strip_namespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_tests</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_tests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parse_generator_matches</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">match_tests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parse_generator_matches</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match_tests</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_depth</span> <span class="o">=</span> <span class="mi">1000000</span> <span class="c1"># effectively, infinity</span>
            <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_tests</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_depth</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">match_depth</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">depth</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_depth</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_ignore</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_ignore</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cdata_separator</span> <span class="o">=</span> <span class="n">cdata_separator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">need_cdata_separator</span><span class="o">=</span><span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_parse_generator_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match_string</span><span class="p">):</span>
        <span class="n">match_obj</span> <span class="o">=</span> <span class="n">_GeneratorMatch</span><span class="p">(</span><span class="n">match_string</span><span class="o">=</span><span class="n">match_string</span><span class="p">)</span>
        <span class="n">parsed_match_string</span> <span class="o">=</span> <span class="n">match_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>

        <span class="c1"># Determine if we had a leading slash</span>
        <span class="k">if</span> <span class="n">parsed_match_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">match_obj</span><span class="o">.</span><span class="n">rooted</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">del</span> <span class="n">parsed_match_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Pop a single trailing slash</span>
        <span class="k">if</span> <span class="n">parsed_match_string</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">parsed_match_string</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Verify there are no other empty elements.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">parsed_match_string</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span>
                    <span class="s2">&quot;Match condition contains empty path elements (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">match_string</span><span class="p">,)</span>
                    <span class="p">)</span>
        <span class="c1"># Get the depth and the element list.</span>
        <span class="n">match_obj</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parsed_match_string</span><span class="p">)</span>
        <span class="n">match_obj</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">parsed_match_string</span>

        <span class="k">return</span> <span class="n">match_obj</span>

    <span class="k">def</span> <span class="nf">_check_generator_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_depth</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_tests</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">rooted</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="o">!=</span> <span class="n">match</span><span class="o">.</span><span class="n">depth</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">rooted</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">match</span><span class="o">.</span><span class="n">depth</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">elements</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="n">match</span><span class="o">.</span><span class="n">depth</span><span class="p">:]:</span>
                <span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">_unicode</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">path</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">match_string</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="p">))</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_build_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespaces</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">strip_namespace</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">full_name</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">full_name</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namespace_separator</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">full_name</span>
        <span class="n">namespace</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">full_name</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">full_name</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strip_namespace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span>
        <span class="n">short_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespaces</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">short_namespace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace_separator</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">short_namespace</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_attrs_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">attrs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strip_namespace</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">rv</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;xmlns&quot;</span> <span class="ow">or</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;xmlns&quot;</span> <span class="o">+</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">namespace_separator</span><span class="p">):</span>
                    <span class="k">del</span> <span class="n">rv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">rv</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namespace_separator</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">newkey</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namespace_separator</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
                    <span class="k">if</span> <span class="n">newkey</span> <span class="ow">in</span> <span class="n">rv</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Stripping namespace causes duplicate attribute </span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">newkey</span><span class="p">)</span>
                    <span class="n">rv</span><span class="p">[</span><span class="n">newkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">rv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">rv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rv</span>

    <span class="k">def</span> <span class="nf">start_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_name</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_name</span><span class="p">(</span><span class="n">full_name</span><span class="p">)</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_to_dict</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xml_attribs</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_name</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_ignore</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_depth</span><span class="p">:</span>
            <span class="c1"># We were ignoring lower levels of the hierarchy. Get a new</span>
            <span class="c1"># root.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">item</span> <span class="o">=</span> <span class="n">XMLDictNode</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_ignore</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_ignore</span><span class="p">:</span>
            <span class="c1"># Add a new item</span>
            <span class="n">newnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">xml_attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>
            <span class="c1"># Save the old item (which may have been updated).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="o">.</span><span class="n">get_current_node</span><span class="p">())</span>
            <span class="c1"># Change the current focus to the new item.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">item</span> <span class="o">=</span> <span class="n">newnode</span>
            <span class="c1"># We don&#39;t need a CDATA separator when starting an item.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">need_cdata_separator</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">end_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_ignore</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strip_whitespace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="o">.</span><span class="n">strip_cdata</span><span class="p">(</span><span class="n">return_node</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_generator_matches</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_depth</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_ignore</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_ignore</span><span class="p">:</span>
            <span class="c1"># We may need a CDATA separator when ending an item.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="o">.</span><span class="n">get_cdata</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">need_cdata_separator</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">characters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_ignore</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">need_cdata_separator</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdata_separator</span> <span class="o">+</span> <span class="n">data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">need_cdata_separator</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="o">.</span><span class="n">append_cdata</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">return_node</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">end_document</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;endDocument() called with open elements&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_generator_matches</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">pop_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">rv</span>

<div class="viewcode-block" id="Parser"><a class="viewcode-back" href="../parsing.html#jxmlease.Parser">[docs]</a><span class="k">class</span> <span class="nc">Parser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates Python data structures from raw XML.</span>
<span class="sd">    </span>
<span class="sd">    This class creates a callable object used to parse XML into Python data</span>
<span class="sd">    structures. You can provide optional parameters at the class creation time.</span>
<span class="sd">    These parameters modify the default behavior of the parser. When you invoke </span>
<span class="sd">    the callable object to parse a document, you can supply additional</span>
<span class="sd">    parameters to override the values specified when the :py:class:`Parser`</span>
<span class="sd">    object was created.</span>

<span class="sd">    General usage is::</span>

<span class="sd">        &gt;&gt;&gt; myparser = Parser()</span>
<span class="sd">        &gt;&gt;&gt; root = myparser(&quot;&lt;a&gt;foo&lt;/a&gt;&quot;)</span>

<span class="sd">    Calling a :py:class:`Parser` object returns an :py:class:`XMLDictNode`</span>
<span class="sd">    containing the parsed XML tree.</span>

<span class="sd">    In this example, ``root`` is an :py:class:`XMLDictNode` which contains a</span>
<span class="sd">    representation of the parsed XML::</span>

<span class="sd">        &gt;&gt;&gt; isinstance(root, XMLDictNode)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; root.prettyprint()</span>
<span class="sd">        {u&#39;a&#39;: u&#39;foo&#39;}</span>
<span class="sd">        &gt;&gt;&gt; print root.emit_xml()</span>
<span class="sd">        &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="sd">        &lt;a&gt;foo&lt;/a&gt;</span>

<span class="sd">    If you will just be using a parser once, you can just use the</span>
<span class="sd">    :py:meth:`parse` method, which is a shortcut way of creating a</span>
<span class="sd">    :py:class:`Parser` class and calling it all in one call. You can provide</span>
<span class="sd">    the same arguments to the :py:meth:`parse` method that you provide to the</span>
<span class="sd">    :py:class:`Parser` class.</span>
<span class="sd">        </span>
<span class="sd">    For example::</span>

<span class="sd">          &gt;&gt;&gt; root = jxmlease.parse(&#39;&lt;a x=&quot;y&quot;&gt;&lt;b&gt;1&lt;/b&gt;&lt;b&gt;2&lt;/b&gt;&lt;b&gt;3&lt;/b&gt;&lt;/a&gt;&#39;)</span>
<span class="sd">          &gt;&gt;&gt; root.prettyprint()</span>
<span class="sd">          {u&#39;a&#39;: {u&#39;b&#39;: [u&#39;1&#39;, u&#39;2&#39;, u&#39;3&#39;]}}</span>

<span class="sd">    It is possible to call a :py:class:`Parser` object as a generator by</span>
<span class="sd">    specifying the :py:attr:`generator` parameter. The :py:attr:`generator`</span>
<span class="sd">    parameter contains a list of paths to match. If paths are provided in this</span>
<span class="sd">    parameter, the behavior of the parser is changed. Instead of returning the</span>
<span class="sd">    root node of a parsed XML hierarchy, the parser returns a generator object.</span>
<span class="sd">    On each call to the generator object, it will return the next node that</span>
<span class="sd">    matches one of the provided paths.</span>
<span class="sd">        </span>
<span class="sd">    Paths are provided in a format similar to XPath expressions. For example,</span>
<span class="sd">    ``/a/b`` will match node ``&lt;b&gt;`` in this XML::</span>

<span class="sd">        &lt;a&gt;</span>
<span class="sd">            &lt;b/&gt;</span>
<span class="sd">        &lt;/a&gt;</span>

<span class="sd">    If a path begins with a ``/``, it must exactly match the full path to a</span>
<span class="sd">    node. If a path does not begin with a ``/``, it must exactly match the</span>
<span class="sd">    &quot;right side&quot; of the path to a node. For example, consider this XML::</span>

<span class="sd">        &lt;a&gt;</span>
<span class="sd">            &lt;b&gt;</span>
<span class="sd">                &lt;c/&gt;</span>
<span class="sd">            &lt;/b&gt;</span>
<span class="sd">        &lt;/a&gt;</span>

<span class="sd">    In this example, ``/a/b/c``, ``c``, ``b/c``, and ``a/b/c`` all match the</span>
<span class="sd">    ``&lt;c&gt;`` node.</span>
<span class="sd">        </span>
<span class="sd">    For each match, the generator returns a tuple of:</span>
<span class="sd">    ``(path,match_string,xml_node)``, where the *path* is</span>
<span class="sd">    the calculated absolute path to the matching node, *match_string* is the</span>
<span class="sd">    user-supplied match string that triggered the match, and *xml_node* is the</span>
<span class="sd">    object representing that node (an instance of a :py:class:`XMLNodeBase`</span>
<span class="sd">    subclass).</span>
<span class="sd">        </span>
<span class="sd">    For example::</span>

<span class="sd">        &gt;&gt;&gt; xml = &#39;&lt;a x=&quot;y&quot;&gt;&lt;b&gt;1&lt;/b&gt;&lt;b&gt;2&lt;/b&gt;&lt;b&gt;3&lt;/b&gt;&lt;/a&gt;&#39;</span>
<span class="sd">        &gt;&gt;&gt; myparser = Parser(generator=[&quot;/a/b&quot;])</span>
<span class="sd">        &gt;&gt;&gt; for (path, match, value) in myparser(xml):</span>
<span class="sd">        ...   print &quot;%s: %s&quot; % (path, value)</span>
<span class="sd">        ...</span>
<span class="sd">        /a/b: 1</span>
<span class="sd">        /a/b: 2</span>
<span class="sd">        /a/b: 3</span>
<span class="sd">    </span>
<span class="sd">    When calling the parser, you can specify all of these parameters. When</span>
<span class="sd">    creating a parsing instance, you can specify all of these parameters</span>
<span class="sd">    except :py:attr:`xml_input`:</span>

<span class="sd">    Args:</span>
<span class="sd">	xml_input (stirng or file-like object): Ccontains the XML to parse.</span>
<span class="sd">	encoding (string or None): The input&#39;s encoding. If not provided, this</span>
<span class="sd">            defaults to &#39;utf-8&#39;.</span>
<span class="sd">        expat (An expat, or equivalent, parser class): Used for parsing the XML</span>
<span class="sd">            input. If not provided, defaults to the expat parser in</span>
<span class="sd">            :py:data:`xml.parsers`.</span>
<span class="sd">        process_namespaces (bool): If True, namespaces in tags and attributes</span>
<span class="sd">            are converted to their full URL value. If False (the default), the</span>
<span class="sd">            namespaces in tags and attributes are left unchanged.</span>
<span class="sd">	namespace_separator (string): If :py:attr:`process_namespaces` is True,</span>
<span class="sd">            this specifies the separator that expat should use between</span>
<span class="sd">            namespaces and identifiers in tags and attributes</span>
<span class="sd">	xml_attribs (bool): If True (the default), include XML attributes.</span>
<span class="sd">            If False, ignore them.</span>
<span class="sd">        strip_whitespace (bool): If True (the default), strip whitespace</span>
<span class="sd">            at the start and end of CDATA. If False, keep all whitespace.</span>
<span class="sd">        namespaces (dict): A remapping for namespaces. If supplied, identifiers</span>
<span class="sd">            with a namespace prefix will have their namespace prefix rewritten</span>
<span class="sd">            based on the dictionary. The code will look for</span>
<span class="sd">            :py:attr:`namespaces[current_namespace]`. If found,</span>
<span class="sd">            :py:obj:`current_namespace` will be replaced with the result of</span>
<span class="sd">            the lookup.</span>
<span class="sd">        strip_namespace (bool): If True, the namespace prefix will be</span>
<span class="sd">            removed from all identifiers. If False (the default), the namespace</span>
<span class="sd">            prefix will be retained.</span>
<span class="sd">        cdata_separator (string): When encountering &quot;semi-structured&quot; XML</span>
<span class="sd">            (where the XML has CDATA and tags intermixed at the same level), the</span>
<span class="sd">            :py:attr:`cdata_separator` will be placed between the different</span>
<span class="sd">            groups of CDATA. By default, the :py:attr:`cdata_separator`</span>
<span class="sd">            parameter is &#39;&#39;, which results in the CDATA groups being</span>
<span class="sd">            concatenated without separator.</span>
<span class="sd">        generator (list of strings): A list of paths to match. If paths are</span>
<span class="sd">            provided here, the behavior of the parser is changed. Instead of</span>
<span class="sd">            returning the root node of a parsed XML hierarchy, the parser</span>
<span class="sd">            returns a :py:obj:`generator` object. On each call to the</span>
<span class="sd">            :py:obj:`generator` object, it will return the next node that</span>
<span class="sd">            matches one of the provided paths.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A callable instance of the :py:class:`Parser` class.</span>

<span class="sd">        Calling a :py:class:`Parser` object returns an :py:class:`XMLDictNode`</span>
<span class="sd">        containing the parsed XML tree.</span>

<span class="sd">        Alternatively, if the :py:attr:`generator` parameter is specified, a </span>
<span class="sd">        :py:obj:`generator` object is returned.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See class documentation.&quot;&quot;&quot;</span>
        <span class="c1"># Populate a dictionary with default arguments.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">expat</span><span class="o">=</span><span class="n">expat</span><span class="p">,</span>
                                    <span class="n">process_namespaces</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                    <span class="n">namespace_separator</span><span class="o">=</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>

        <span class="c1"># Update the dictionary with user-provided defaults.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">parser_defaults</span><span class="p">)</span>

        <span class="c1"># Update the dictionary with the provided arguments. We will save</span>
        <span class="c1"># the arguments for later use.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Process the arguments.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_args</span><span class="p">()</span>

        <span class="c1"># Make a default handler, which will also try the arguments to catch</span>
        <span class="c1"># argument errors now.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_handler</span><span class="p">()</span>

        <span class="c1"># Try the arguments to catch argument errors now. We will</span>
        <span class="c1"># throw this one away (as the encoding is unpredictable).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="s1">&#39;utf-8&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_parser</span><span class="p">()</span>

        <span class="c1"># Stash the handler for future use.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_process_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Make a copy of the default kwargs database.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_kwargs</span><span class="p">)</span>

        <span class="c1"># Update the dictionary with the provided arguments.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Pop off and save the arguments that we don&#39;t want to pass to</span>
        <span class="c1"># the handler class.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;encoding&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;expat&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_namespaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;process_namespaces&#39;</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">_make_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span> <span class="o">=</span> <span class="n">_DictSAXHandler</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># We don&#39;t need a namespace separator if we&#39;re not processing</span>
        <span class="c1"># namespaces.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_namespaces</span><span class="p">:</span>
            <span class="n">namespace_separator</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">namespace_separator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">[</span><span class="s1">&#39;namespace_separator&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expat</span><span class="o">.</span><span class="n">ParserCreate</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">,</span> <span class="n">namespace_separator</span>
        <span class="p">)</span>

        <span class="c1"># Setup some parser attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parser</span><span class="o">.</span><span class="n">buffer_text</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parser</span><span class="o">.</span><span class="n">ordered_attributes</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># pragma no cover</span>
            <span class="c1"># Jython&#39;s expat does not support ordered_attributes</span>
            <span class="k">pass</span>

        <span class="c1"># Assign the handler methods to the parser</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parser</span><span class="o">.</span><span class="n">StartElementHandler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">start_element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parser</span><span class="o">.</span><span class="n">EndElementHandler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">end_element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parser</span><span class="o">.</span><span class="n">CharacterDataHandler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">characters</span>

    <span class="k">def</span> <span class="nf">_parse_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_input</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xml_input</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">_unicode</span><span class="p">)):</span>
            <span class="n">io_obj</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="n">xml_input</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xml_input</span><span class="p">,</span> <span class="n">_bytes</span><span class="p">):</span>
            <span class="n">io_obj</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">(</span><span class="n">xml_input</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">io_obj</span> <span class="o">=</span> <span class="n">xml_input</span>

        <span class="n">at_eof</span><span class="o">=</span><span class="bp">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">at_eof</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">io_obj</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">parsing_increment</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">at_eof</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parser</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">at_eof</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">expat</span><span class="o">.</span><span class="n">ExpatError</span><span class="p">:</span>
                <span class="c1"># Note: &quot;except expat.ExpatError as e&quot; is not</span>
                <span class="c1"># supported in older Python version. Once support for</span>
                <span class="c1"># those versions is deprecated, we should consider</span>
                <span class="c1"># changing this to the more standard syntax.</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># If the only error was parsing an empty document, ignore</span>
                <span class="c1"># the error and return the empty dictionary.</span>
                <span class="n">raise_error</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">expat</span><span class="p">,</span> <span class="s2">&quot;errors&quot;</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">hasattr</span><span class="p">(</span><span class="n">expat</span><span class="o">.</span><span class="n">errors</span><span class="p">,</span> <span class="s2">&quot;XML_ERROR_NO_ELEMENTS&quot;</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">at_eof</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">expat</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">XML_ERROR_NO_ELEMENTS</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span><span class="p">):</span>
                        <span class="n">raise_error</span> <span class="o">=</span> <span class="bp">False</span>

                <span class="c1"># If needed, raise the error</span>
                <span class="k">if</span> <span class="n">raise_error</span><span class="p">:</span>
                    <span class="k">raise</span>

            <span class="k">if</span> <span class="n">at_eof</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">end_document</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">rv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">pop_matches</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">rv</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_input</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See class documentation.&quot;&quot;&quot;</span>
        <span class="c1"># Make a copy of the default arguments and update that copy with</span>
        <span class="c1"># our new arguments.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_args</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="c1"># Did we get keyword arguments? If so, we need to recreate the</span>
        <span class="c1"># default handler. Otherwise, we can try to use it (if the default</span>
        <span class="c1"># parser exists).</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_handler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_handler</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_default_handler</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_handler</span><span class="p">()</span>

        <span class="c1"># Make sure our unicode text (if any) is properly encoded.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xml_input</span><span class="p">,</span> <span class="n">_unicode</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="s1">&#39;utf-8&#39;</span>
            <span class="n">xml_input</span> <span class="o">=</span> <span class="n">xml_input</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">)</span>

        <span class="c1"># Create our parser.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_parser</span><span class="p">()</span>

        <span class="c1"># Do the actual parsing.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;generator&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_generator</span><span class="p">(</span><span class="n">xml_input</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xml_input</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">_unicode</span><span class="p">,</span> <span class="n">_bytes</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_parser</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml_input</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_parser</span><span class="o">.</span><span class="n">ParseFile</span><span class="p">(</span><span class="n">xml_input</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">expat</span><span class="o">.</span><span class="n">ExpatError</span><span class="p">:</span>
                <span class="c1"># Note: &quot;except expat.ExpatError as e&quot; is not</span>
                <span class="c1"># supported in older Python version. Once support for</span>
                <span class="c1"># those versions is deprecated, we should consider</span>
                <span class="c1"># changing this to the more standard syntax.</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># If the only error was parsing an empty document, ignore</span>
                <span class="c1"># the error and return the empty dictionary.</span>
                <span class="n">raise_error</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">expat</span><span class="p">,</span> <span class="s2">&quot;errors&quot;</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">hasattr</span><span class="p">(</span><span class="n">expat</span><span class="o">.</span><span class="n">errors</span><span class="p">,</span> <span class="s2">&quot;XML_ERROR_NO_ELEMENTS&quot;</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">expat</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">XML_ERROR_NO_ELEMENTS</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span><span class="p">):</span>
                        <span class="n">raise_error</span> <span class="o">=</span> <span class="bp">False</span>

                <span class="c1"># If needed, raise the error</span>
                <span class="k">if</span> <span class="n">raise_error</span><span class="p">:</span>
                    <span class="k">raise</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">item</span></div>

<div class="viewcode-block" id="parse"><a class="viewcode-back" href="../parsing.html#jxmlease.parse">[docs]</a><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">xml_input</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create Python data structures from raw XML.</span>
<span class="sd">    </span>
<span class="sd">    See the :py:class:`Parser` class documentation.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Parser</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)(</span><span class="n">xml_input</span><span class="p">)</span></div>

<span class="k">if</span> <span class="n">etree</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">NamespaceError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">namespace</span>
        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;Namespace </span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s2"> not found in namespace store.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span>
                <span class="p">)</span>
        <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(namespace=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span><span class="p">)</span>

<div class="viewcode-block" id="EtreeParser"><a class="viewcode-back" href="../parsing.html#jxmlease.EtreeParser">[docs]</a>    <span class="k">class</span> <span class="nc">EtreeParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates Python data structures from an ElementTree object.</span>
<span class="sd">    </span>
<span class="sd">        This class returns a callable object. You can provide parameters at</span>
<span class="sd">        the class creation time. These parameters modify the default</span>
<span class="sd">        parameters for the parser. When you call the callable object to</span>
<span class="sd">        parse a document, you can supply additional parameters to override</span>
<span class="sd">        the default values.</span>
<span class="sd">    </span>
<span class="sd">        General usage is like this::</span>

<span class="sd">            &gt;&gt;&gt; myparser = Parser()</span>
<span class="sd">            &gt;&gt;&gt; root = myparser(etree_root)</span>
<span class="sd">        </span>
<span class="sd">        For detailed usage information, please see the :py:class`Parser`</span>
<span class="sd">        class. Other than the differences noted below, the behavior of</span>
<span class="sd">        the two classes should be the same.</span>
<span class="sd">        </span>
<span class="sd">        Namespace Identifiers:</span>

<span class="sd">        In certain versions of :py:mod:`ElementTree`, the original namespace</span>
<span class="sd">        identifiers are not maintained. In these cases, the class will recreate</span>
<span class="sd">        namespace identfiers to represent the original namespaces. It will add</span>
<span class="sd">        appropriate xmlns attributes to maintain the original namespace</span>
<span class="sd">        mapping. However, the actual identifier will be lost. As best I can</span>
<span class="sd">        tell, this is a bug with :py:mod:`ElementTree`, rather than this code.</span>
<span class="sd">        To avoid this problem, use :py:mod:`lxml`.</span>

<span class="sd">        Single-invocation Parsing:</span>

<span class="sd">        If you will just be using a parser once, you can just use the</span>
<span class="sd">        :py:meth:`parse_etree` method, which is a shortcut way of creating a</span>
<span class="sd">        :py:class:`EtreeParser` class and calling it all in one call. You</span>
<span class="sd">        can provide the same arguments to the :py:meth:`parse_etree` method</span>
<span class="sd">        that you can provide to the :py:class:`EtreeParser` class.</span>

<span class="sd">        Args:</span>
<span class="sd">            etree_root (ElementTree): An ElementTree object representing the</span>
<span class="sd">                tree you wish to parse.</span>

<span class="sd">        Also accepts most of the same arguments as the :py:class:`Parser` class.</span>
<span class="sd">        However, it does not accept the :py:attr:`xml_input`, :py:attr:`expat`,</span>
<span class="sd">        or :py:attr:`encoding` parameters.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;See the class documentation.&quot;&quot;&quot;</span>
            <span class="c1"># Populate a dictionary with default arguments.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_default_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">process_namespaces</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                        <span class="n">namespace_separator</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span>
                                        <span class="n">strip_namespace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

            <span class="c1"># Update the dictionary with user-provided defaults, after</span>
            <span class="c1"># stripping out arguments not appropriate for this</span>
            <span class="c1"># context.</span>
            <span class="n">local_parser_defaults</span> <span class="o">=</span> <span class="n">parser_defaults</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;encoding&#39;</span><span class="p">,</span> <span class="s1">&#39;expat&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">local_parser_defaults</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">local_parser_defaults</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_default_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">local_parser_defaults</span><span class="p">)</span>

            <span class="c1"># Update the dictionary with the provided arguments. We will save</span>
            <span class="c1"># the arguments for later use.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_default_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Process the arguments.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_args</span><span class="p">()</span>

            <span class="c1"># Make a default handler, which will also try the arguments to</span>
            <span class="c1"># catch argument errors now.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_handler</span><span class="p">()</span>

            <span class="c1"># Stash the handler for future use.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_default_handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">def</span> <span class="nf">_process_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># Make a copy of the default kwargs database.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_kwargs</span><span class="p">)</span>

            <span class="c1"># Update the dictionary with the provided arguments.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Pop off and save the argument(s) that we don&#39;t want to pass</span>
            <span class="c1"># to the handler class.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_namespaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;process_namespaces&#39;</span><span class="p">)</span>
            
            <span class="c1"># Get local versions of the arguments we want.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_separator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">[</span><span class="s1">&#39;namespace_separator&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strip_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">[</span><span class="s1">&#39;strip_namespace&#39;</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">_make_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span> <span class="o">=</span> <span class="n">_DictSAXHandler</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="c1"># Initialize the namespace_dict. We use this to store locally-</span>
            <span class="c1"># generated namespace mappings if the originals are lost.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nexttag&#39;</span><span class="p">:</span> <span class="n">_unicode</span><span class="p">(</span><span class="s1">&#39;ns0&#39;</span><span class="p">)}</span>

            <span class="c1"># Call the main parsing function</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">root_element</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_parse_attrib</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dict</span><span class="p">,</span> <span class="n">out_dict</span><span class="p">,</span> <span class="n">nsdict</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">parsed_attr</span> <span class="o">=</span> <span class="n">QNameSeparator</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">parsed_attr</span><span class="o">.</span><span class="n">namespace</span><span class="p">:</span>
                    <span class="n">out_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="k">del</span> <span class="n">in_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">new_ns</span> <span class="o">=</span> <span class="n">nsdict</span><span class="p">[</span><span class="n">parsed_attr</span><span class="o">.</span><span class="n">namespace</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">NamespaceError</span><span class="p">(</span><span class="n">parsed_attr</span><span class="o">.</span><span class="n">namespace</span><span class="p">)</span>
                    <span class="n">new_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">new_ns</span><span class="p">,</span>
                         <span class="n">parsed_attr</span><span class="o">.</span><span class="n">localname</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">out_dict</span><span class="p">[</span><span class="n">new_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="k">del</span> <span class="n">in_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">_parse_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">local_nsdict</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">root_element</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
            <span class="c1"># Parsing LXML/ElementTree is actually quite simple. We</span>
            <span class="c1"># can just recursively call this function to walk through</span>
            <span class="c1"># the tree of elements and call the same handler we use</span>
            <span class="c1"># for parsing the text version through a SAX parser.</span>
            <span class="c1"># Almost all of the complexity is handling the namespaces.</span>

            <span class="c1"># Make a local copy of the namespace dict. This lets us</span>
            <span class="c1"># track whether we need to add xmlns attributes to lower</span>
            <span class="c1"># levels.</span>
            <span class="k">if</span> <span class="n">local_nsdict</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">local_nsdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_dict</span>
            <span class="n">local_nsdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">local_nsdict</span><span class="p">)</span>

            <span class="c1"># Ignore processing instructions and comments.</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">PI</span><span class="p">,</span> <span class="n">etree</span><span class="o">.</span><span class="n">Comment</span><span class="p">):</span>
                <span class="c1"># Figure out NS:</span>
                <span class="c1"># If &#39;strip_namespace&#39; or &#39;process_namespaces&#39; are set, we</span>
                <span class="c1"># can do the same thing. In these cases, we just care about</span>
                <span class="c1"># making sure the attributes and tags are formed correctly so</span>
                <span class="c1"># that the handler will do the correct thing. In general, our</span>
                <span class="c1"># goal is to emulate what the expat processor would do if</span>
                <span class="c1"># process_namespaces was set to True.</span>
                <span class="c1">#</span>
                <span class="c1"># Otherwise, try to restore the original nodename (&quot;ns:tag&quot;)</span>
                <span class="c1"># and XMLNS attributes. (Again, this emulates what the expat</span>
                <span class="c1"># processor would do.) If we&#39;ve lost the original</span>
                <span class="c1"># namespace identifiers, make up our own.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strip_namespace</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_namespaces</span><span class="p">:</span>
                    <span class="n">parsed_tag</span> <span class="o">=</span> <span class="n">QNameDecode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">parsed_tag</span><span class="o">.</span><span class="n">namespace</span><span class="p">:</span>
                        <span class="n">tag</span> <span class="o">=</span> <span class="n">parsed_tag</span><span class="o">.</span><span class="n">localname</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">parsed_tag</span><span class="o">.</span><span class="n">namespace</span><span class="p">,</span> <span class="n">parsed_tag</span><span class="o">.</span><span class="n">localname</span><span class="p">)</span>
                        <span class="p">)</span>

                    <span class="c1"># Fix the attributes. Just paste them together with</span>
                    <span class="c1"># the namespace separator. The standard parsing code</span>
                    <span class="c1"># can handle them further. (In the case where</span>
                    <span class="c1"># strip_namespace is set, it can check for name</span>
                    <span class="c1"># conflicts (e.g.  &lt;a a:attr1=&quot;&quot; b:attr1=&quot;&quot;</span>
                    <span class="c1"># c:attr1=&quot;&quot;/&gt;). That is the reason we don&#39;t strip</span>
                    <span class="c1"># them out here when strip_namespace is true. It seems</span>
                    <span class="c1"># best to have the logic in a single place.</span>
                    <span class="n">attrib</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">parsed_attr</span> <span class="o">=</span> <span class="n">QNameSeparator</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">parsed_attr</span><span class="o">.</span><span class="n">namespace</span><span class="p">:</span>
                            <span class="n">attrib</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                <span class="p">(</span><span class="n">parsed_attr</span><span class="o">.</span><span class="n">namespace</span><span class="p">,</span>
                                 <span class="n">parsed_attr</span><span class="o">.</span><span class="n">localname</span><span class="p">)</span>
                            <span class="p">)</span>
                            <span class="n">attrib</span><span class="p">[</span><span class="n">new_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;nsmap&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">nsmap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># If nsmap is present (lxml) and it is 0, then we</span>
                    <span class="c1"># should have no namespace information to process.</span>
                    <span class="c1"># If nsmap is present and it is greater than 0,</span>
                    <span class="c1"># then we want to process the namespace information,</span>
                    <span class="c1"># even if all we do is create proper xmlns attributes.</span>
                    <span class="n">tag</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span>
                    <span class="n">attrib</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If the node has the nsmap attribute, reverse it to</span>
                    <span class="c1"># create a namespace lookup dictionary for us.</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;nsmap&#39;</span><span class="p">):</span>
                        <span class="n">ns_resolve_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">nsmap</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                                                   <span class="n">node</span><span class="o">.</span><span class="n">nsmap</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="c1"># If the node doesn&#39;t have the nsmap attribute, all NS</span>
                    <span class="c1"># identfiers are lost. We can recreate them with</span>
                    <span class="c1"># locally-generated identifiers, which we store in the</span>
                    <span class="c1"># namespace_dict.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ns_resolve_dict</span> <span class="o">=</span> <span class="n">local_nsdict</span>

                    <span class="c1"># Initialize the new attributes</span>
                    <span class="n">attrib</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

                    <span class="c1"># Determine if we need to add a namespace to the tag.</span>
                    <span class="n">parsed_tag</span> <span class="o">=</span> <span class="n">QNameDecode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">parsed_tag</span><span class="o">.</span><span class="n">namespace</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="ow">not</span> <span class="n">ns_resolve_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">parsed_tag</span><span class="o">.</span><span class="n">namespace</span><span class="p">,</span>
                                                 <span class="s1">&#39;@@NOMATCH@@&#39;</span><span class="p">))):</span>
                        <span class="n">tag</span> <span class="o">=</span> <span class="n">parsed_tag</span><span class="o">.</span><span class="n">localname</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># If the namespace isn&#39;t in our resolver dictionary,</span>
                        <span class="c1"># add it to the namespace_dict. Note that this</span>
                        <span class="c1"># will not work correctly if the node had an nsmap.</span>
                        <span class="c1"># It isn&#39;t supposed to work correctly in that case.</span>
                        <span class="c1"># If the tag uses a namespace that isn&#39;t in the</span>
                        <span class="c1"># nsmap, that seems like a bug.</span>
                        <span class="k">if</span> <span class="n">parsed_tag</span><span class="o">.</span><span class="n">namespace</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns_resolve_dict</span><span class="p">:</span>
                            <span class="c1"># If we&#39;ve already seen this in a sibling branch,</span>
                            <span class="c1"># use a consistent NS identifier. Otherwise, add</span>
                            <span class="c1"># the identifier to the main database.</span>
                            <span class="k">if</span> <span class="n">parsed_tag</span><span class="o">.</span><span class="n">namespace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_dict</span><span class="p">:</span>
                                <span class="n">newns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_dict</span><span class="p">[</span><span class="n">parsed_tag</span><span class="o">.</span><span class="n">namespacein</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">newns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_dict</span><span class="p">[</span><span class="s1">&#39;nexttag&#39;</span><span class="p">]</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_dict</span><span class="p">[</span><span class="n">parsed_tag</span><span class="o">.</span><span class="n">namespace</span><span class="p">]</span> <span class="o">=</span> <span class="n">newns</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_dict</span><span class="p">[</span><span class="s1">&#39;nexttag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unicode</span><span class="p">(</span>
                                    <span class="s2">&quot;ns</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">newns</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">)</span>
                                <span class="p">)</span>
                            <span class="c1"># Add the identifier to the local database, and</span>
                            <span class="c1"># add an xmlns: attribute to cover this branch.</span>
                            <span class="n">ns_resolve_dict</span><span class="p">[</span><span class="n">parsed_tag</span><span class="o">.</span><span class="n">namespace</span><span class="p">]</span> <span class="o">=</span> <span class="n">newns</span>
                            <span class="n">attrib</span><span class="p">[</span><span class="n">_unicode</span><span class="p">(</span><span class="s2">&quot;xmlns:&quot;</span> <span class="o">+</span> <span class="n">newns</span><span class="p">)]</span> <span class="o">=</span> <span class="n">parsed_tag</span><span class="o">.</span><span class="n">namespace</span>
                        <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">ns_resolve_dict</span><span class="p">[</span><span class="n">parsed_tag</span><span class="o">.</span><span class="n">namespace</span><span class="p">],</span>
                             <span class="n">parsed_tag</span><span class="o">.</span><span class="n">localname</span><span class="p">)</span>
                        <span class="p">)</span>

                    <span class="c1"># Deal with the attributes.</span>
                    <span class="n">old_attrib</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">)</span>
                    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_attrib</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_attrib</span><span class="p">(</span>
                                <span class="n">old_attrib</span><span class="p">,</span> <span class="n">attrib</span><span class="p">,</span> <span class="n">ns_resolve_dict</span>
                            <span class="p">)</span>
                        <span class="k">except</span> <span class="n">NamespaceError</span><span class="p">:</span>
                            <span class="c1"># NOTE: &quot;except NamespaceError as e&quot; is not</span>
                            <span class="c1"># supported in older Python versions. Once</span>
                            <span class="c1"># support for those versions is deprecated, we</span>
                            <span class="c1"># should consider changing this to the more</span>
                            <span class="c1"># standard syntax.</span>
                            <span class="n">e</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;nsmap&#39;</span><span class="p">):</span>
                                <span class="k">raise</span>

                            <span class="c1"># If we&#39;ve already seen this in a sibling branch,</span>
                            <span class="c1"># use a consistent NS identifier. Otherwise, add</span>
                            <span class="c1"># the identifier to the main database.</span>
                            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">namespace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_dict</span><span class="p">:</span>
                                <span class="n">newns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_dict</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">namespace</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">newns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_dict</span><span class="p">[</span><span class="s1">&#39;nexttag&#39;</span><span class="p">]</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_dict</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">namespace</span><span class="p">]</span> <span class="o">=</span> <span class="n">newns</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_namespace_dict</span><span class="p">[</span><span class="s1">&#39;nexttag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unicode</span><span class="p">(</span>
                                    <span class="s2">&quot;ns</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">newns</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">)</span>
                                <span class="p">)</span>

                            <span class="c1"># Add the identifier to the local database, and</span>
                            <span class="c1"># add an xmlns: attribute to cover this branch.</span>
                            <span class="n">ns_resolve_dict</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">namespace</span><span class="p">]</span> <span class="o">=</span> <span class="n">newns</span>
                            <span class="n">attrib</span><span class="p">[</span><span class="n">_unicode</span><span class="p">(</span><span class="s2">&quot;xmlns:&quot;</span> <span class="o">+</span> <span class="n">newns</span><span class="p">)]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">namespace</span>

                            
                    <span class="c1"># Add any necessary xmlns tags.</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;nsmap&quot;</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">root_element</span><span class="p">:</span>
                            <span class="n">parent_nsmap</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">parent_nsmap</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">getparent</span><span class="p">()</span><span class="o">.</span><span class="n">nsmap</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">nsmap</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">parent_nsmap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39;@@NOMATCH@@&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">k</span><span class="p">:</span>
                                    <span class="n">attrib</span><span class="p">[</span><span class="n">_unicode</span><span class="p">(</span><span class="s2">&quot;xmlns:&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">attrib</span><span class="p">[</span><span class="n">_unicode</span><span class="p">(</span><span class="s2">&quot;xmlns&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">start_element</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">attrib</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">text</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">characters</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">rv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_node</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">local_nsdict</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">rv</span>
                    <span class="k">for</span> <span class="n">rv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">pop_matches</span><span class="p">():</span>
                        <span class="k">yield</span> <span class="n">rv</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">end_element</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">root_element</span><span class="p">)</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">tail</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tail</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">characters</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tail</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root_element</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">end_document</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">rv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">pop_matches</span><span class="p">():</span>
                    <span class="k">yield</span> <span class="n">rv</span>

        <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">etree_root</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;See the class documentation.&quot;&quot;&quot;</span>
            <span class="c1"># Make a copy of the default arguments and update that copy with</span>
            <span class="c1"># our new arguments.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_args</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Did we get keyword arguments? If so, we need to recreate the</span>
            <span class="c1"># default handler. Otherwise, we can try to use it (if the default</span>
            <span class="c1"># parser exists).</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_handler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_handler</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_default_handler</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_make_handler</span><span class="p">()</span>

            <span class="c1"># Figure out which node we should hand to the parser.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="n">etree</span><span class="o">.</span><span class="n">_ElementTree</span><span class="p">):</span>
                    <span class="n">etree_root</span> <span class="o">=</span> <span class="n">etree_root</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="n">etree</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">):</span>
                        <span class="n">etree_root</span> <span class="o">=</span> <span class="n">etree_root</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;tag&#39;</span><span class="p">):</span>
                        <span class="n">etree_root</span> <span class="o">=</span> <span class="n">etree_root</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>

            <span class="c1"># Get the generator</span>
            <span class="n">childIter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">etree_root</span><span class="p">)</span>

            <span class="c1"># If we are supposed to run as a generator, return it.</span>
            <span class="c1"># Otherwise, simply loop through every item in the</span>
            <span class="c1"># generator (which should be just a single instance), and</span>
            <span class="c1"># return the item left over at the end.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;generator&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">childIter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">childIter</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handler</span><span class="o">.</span><span class="n">item</span></div>

<div class="viewcode-block" id="parse_etree"><a class="viewcode-back" href="../parsing.html#jxmlease.parse_etree">[docs]</a>    <span class="k">def</span> <span class="nf">parse_etree</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create Python data structures from an ElementTree object.</span>
<span class="sd">    </span>
<span class="sd">        See the py:class:`EtreeParser` class documentation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EtreeParser</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)(</span><span class="n">etree_root</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/juniper_logo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Juniper Networks.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>